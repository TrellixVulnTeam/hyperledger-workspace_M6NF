{
  "_args": [
    [
      {
        "raw": "routing-controllers@^0.6.7",
        "scope": null,
        "escapedName": "routing-controllers",
        "name": "routing-controllers",
        "rawSpec": "^0.6.7",
        "spec": ">=0.6.7 <0.7.0",
        "type": "range"
      },
      "/home/gunungmerapi/wajid-projects/hyperledger-workspace/taxtime-quick-biz-loans-api"
    ]
  ],
  "_from": "routing-controllers@>=0.6.7 <0.7.0",
  "_id": "routing-controllers@0.6.12",
  "_inCache": true,
  "_location": "/routing-controllers",
  "_nodeVersion": "6.6.0",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/routing-controllers-0.6.12.tgz_1491214507478_0.34735304466448724"
  },
  "_npmUser": {
    "name": "pleerock",
    "email": "zarrhost@gmail.com"
  },
  "_npmVersion": "3.10.3",
  "_phantomChildren": {},
  "_requested": {
    "raw": "routing-controllers@^0.6.7",
    "scope": null,
    "escapedName": "routing-controllers",
    "name": "routing-controllers",
    "rawSpec": "^0.6.7",
    "spec": ">=0.6.7 <0.7.0",
    "type": "range"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/routing-controllers/-/routing-controllers-0.6.12.tgz",
  "_shasum": "1889165903e70e406dbf11e2268a8684f8da8def",
  "_shrinkwrap": null,
  "_spec": "routing-controllers@^0.6.7",
  "_where": "/home/gunungmerapi/wajid-projects/hyperledger-workspace/taxtime-quick-biz-loans-api",
  "author": {
    "name": "Umed Khudoiberdiev",
    "email": "pleerock.me@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/pleerock/routing-controllers/issues"
  },
  "dependencies": {
    "class-transformer": "~0.1.3",
    "class-validator": "^0.6.8",
    "cookie": "^0.3.1",
    "glob": "^7.0.5",
    "reflect-metadata": "^0.1.3"
  },
  "description": "Allows to use class-based controllers with express.js or koa in Typescript",
  "devDependencies": {
    "@types/chai": "^3.4.34",
    "@types/chai-as-promised": "0.0.29",
    "@types/express": "^4.0.34",
    "@types/express-session": "0.0.32",
    "@types/koa": "^2.0.37",
    "@types/mocha": "^2.2.37",
    "@types/node": "^7.0.0",
    "@types/sinon": "^1.16.34",
    "body-parser": "^1.15.2",
    "chai": "^3.4.1",
    "chai-as-promised": "^6.0.0",
    "chakram": "^1.4.0",
    "del": "^2.2.1",
    "es6-shim": "^0.35.1",
    "express": "^4.14.0",
    "express-session": "^1.14.1",
    "gulp": "^3.9.1",
    "gulp-istanbul": "^1.0.0",
    "gulp-mocha": "^3.0.1",
    "gulp-replace": "^0.5.4",
    "gulp-shell": "^0.5.0",
    "gulp-sourcemaps": "^2.4.0",
    "gulp-tslint": "^7.0.1",
    "gulp-typescript": "^3.1.4",
    "gulpclass": "^0.1.1",
    "handlebars": "^4.0.6",
    "koa": "^2.0.0",
    "koa-bodyparser": "^3.1.0",
    "koa-convert": "^1.2.0",
    "koa-multer": "^1.0.1",
    "koa-router": "^7.0.1",
    "koa-session": "^3.4.0",
    "koa-views": "^5.2.0",
    "mocha": "^3.0.0",
    "multer": "^1.1.0",
    "mustache-express": "^1.2.2",
    "remap-istanbul": "^0.8.4",
    "request": "^2.74.0",
    "sinon": "^1.17.4",
    "sinon-chai": "^2.8.0",
    "tslint": "^4.3.1",
    "tslint-stylish": "^2.1.0-beta",
    "typedi": "^0.4.2",
    "typescript": "^2.1.5"
  },
  "directories": {},
  "dist": {
    "shasum": "1889165903e70e406dbf11e2268a8684f8da8def",
    "tarball": "https://registry.npmjs.org/routing-controllers/-/routing-controllers-0.6.12.tgz"
  },
  "homepage": "https://github.com/pleerock/routing-controllers#readme",
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "hbakhtiyor",
      "email": "bakhtiyor.h@gmail.com"
    },
    {
      "name": "pleerock",
      "email": "zarrhost@gmail.com"
    }
  ],
  "name": "routing-controllers",
  "optionalDependencies": {},
  "private": false,
  "readme": "# routing-controllers\r\n\r\n[![Build Status](https://travis-ci.org/pleerock/routing-controllers.svg?branch=master)](https://travis-ci.org/pleerock/routing-controllers)\r\n[![codecov](https://codecov.io/gh/pleerock/routing-controllers/branch/master/graph/badge.svg)](https://codecov.io/gh/pleerock/routing-controllers)\r\n[![npm version](https://badge.fury.io/js/routing-controllers.svg)](https://badge.fury.io/js/routing-controllers)\r\n[![Dependency Status](https://david-dm.org/pleerock/routing-controllers.svg)](https://david-dm.org/pleerock/routing-controllers)\r\n[![devDependency Status](https://david-dm.org/pleerock/routing-controllers/dev-status.svg)](https://david-dm.org/pleerock/routing-controllers#info=devDependencies)\r\n[![Join the chat at https://gitter.im/pleerock/routing-controllers](https://badges.gitter.im/pleerock/routing-controllers.svg)](https://gitter.im/pleerock/routing-controllers?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nAllows to create controller classes with methods as actions that handle requests.\r\nYou can use routing-controllers with [express.js][1] or [koa.js][2].\r\n\r\n# Table of Contents\r\n\r\n  * [Installation](#installation)\r\n  * [Example of usage](#example-of-usage)\r\n  * [More usage examples](#more-usage-examples)\r\n      - [Return promises](#return-promises)\r\n      - [Using Request and Response objects](#using-request-and-response-objects)\r\n      - [Using exist server instead of creating a new one](#using-exist-server-instead-of-creating-a-new-one)\r\n      - [Load all controllers from the given directory](#load-all-controllers-from-the-given-directory)\r\n      - [Load all controllers from the given directory and prefix routes](#load-all-controllers-from-the-given-directory-and-prefix-routes)\r\n      - [Prefix controller with base route](#prefix-controller-with-base-route)\r\n      - [Using JSON instead of regular text content](#using-json-instead-of-regular-text-content)\r\n      - [Per-action JSON / non-JSON output](#per-action-json--non-json-output)\r\n      - [Inject routing parameters](#inject-routing-parameters)\r\n      - [Inject query parameters](#inject-query-parameters)\r\n      - [Inject request body](#inject-request-body)\r\n      - [Inject request body parameters](#inject-request-body-parameters)\r\n      - [Inject request header parameters](#inject-request-header-parameters)\r\n      - [Inject session object](#inject-session-object)\r\n      - [Inject uploaded file](#inject-uploaded-file)\r\n      - [Inject uploaded files](#inject-uploaded-files)\r\n      - [Inject cookie parameter](#inject-cookie-parameter)\r\n      - [Make parameter required](#make-parameter-required)\r\n      - [Set custom ContentType](#set-custom-contenttype)\r\n      - [Set Location](#set-location)\r\n      - [Set Redirect](#set-redirect)\r\n      - [Set custom HTTP code](#set-custom-http-code)\r\n      - [Set custom headers](#set-custom-headers)\r\n      - [Render templates](#render-templates)\r\n  * [Using middlewares](#using-middlewares)\r\n    + [Use exist middleware](#use-exist-middleware)\r\n    + [Creating your own express middleware](#creating-your-own-express-middleware)\r\n    + [Creating your own koa middleware](#creating-your-own-koa-middleware)\r\n    + [Global middlewares](#global-middlewares)\r\n    + [Error handlers](#error-handlers)\r\n  * [Using interceptors](#using-interceptors)\r\n    + [Interceptor function](#interceptor-function)\r\n    + [Interceptor classes](#interceptor-classes)\r\n    + [Global interceptors](#global-interceptors)\r\n    + [Don't forget to load your middlewares, error handlers and interceptors](#dont-forget-to-load-your-middlewares-error-handlers-and-interceptors)\r\n  * [Creating instances of classes from action params](#creating-instances-of-classes-from-action-params)\r\n  * [Auto validating action params](#auto-validating-action-params)\r\n  * [Default error handling](#default-error-handling)\r\n  * [Using DI container](#using-di-container)\r\n  * [Decorators Reference](#decorators-reference)\r\n      - [Controller Decorators](#controller-decorators)\r\n      - [Controller Method Decorators](#controller-method-decorators)\r\n      - [Method Parameter Decorators](#method-parameter-decorators)\r\n      - [Middleware and Interceptor Decorators](#middleware-and-interceptor-decorators)\r\n      - [Other Decorators](#other-decorators)\r\n  * [Samples](#samples)\r\n  * [Release notes](#release-notes)\r\n\r\n## Installation\r\n\r\n1. Install module:\r\n\r\n    `npm install routing-controllers --save`\r\n\r\n2. `reflect-metadata` shim is required:\r\n\r\n    `npm install reflect-metadata --save`\r\n\r\n    and make sure to import it in a global place, like app.ts:\r\n\r\n    ```javascript\r\n    import \"reflect-metadata\";\r\n    ```\r\n\r\n3. ES6 features are used, if you are using old version of node.js you may need to install\r\n [es6-shim](https://github.com/paulmillr/es6-shim):\r\n\r\n    `npm install es6-shim --save`\r\n\r\n    and import it in a global place like app.ts:\r\n\r\n    ```javascript\r\n    import \"es6-shim\";\r\n    ```\r\n\r\n4. Install framework:\r\n\r\n    **a. If you want to use routing-controllers with *express.js*, then install it and all required dependencies:**\r\n\r\n    `npm install express body-parser multer --save`\r\n\r\n    Optionally you can also install its [typings](https://github.com/typings/typings):\r\n\r\n    `typings install dt~express dt~serve-static --save --global`\r\n\r\n    **b. If you want to use routing-controllers with *koa 2*, then install it and all required dependencies:**\r\n\r\n    `npm install koa@next koa-router@next koa-bodyparser@next koa-multer --save`\r\n\r\n    Optionally you can also install its [typings](https://github.com/typings/typings):\r\n\r\n    `typings install dt~koa --save --global`\r\n    \r\n5. Its important to set these options in `tsconfig.json` file of your project:\r\n\r\n    ```json\r\n    {\r\n        \"emitDecoratorMetadata\": true,\r\n        \"experimentalDecorators\": true\r\n    }\r\n    ```\r\n\r\n## Example of usage\r\n\r\n1. Create a file `UserController.ts`\r\n\r\n    ```javascript\r\n    import {Controller, Param, Body, Get, Post, Put, Delete} from \"routing-controllers\";\r\n\r\n    @Controller()\r\n    export class UserController {\r\n\r\n        @Get(\"/users\")\r\n        getAll() {\r\n           return \"This action returns all users\";\r\n        }\r\n\r\n        @Get(\"/users/:id\")\r\n        getOne(@Param(\"id\") id: number) {\r\n           return \"This action returns user #\" + id;\r\n        }\r\n\r\n        @Post(\"/users\")\r\n        post(@Body() user: any) {\r\n           return \"Saving user...\";\r\n        }\r\n\r\n        @Put(\"/users/:id\")\r\n        put(@Param(\"id\") id: number, @Body() user: any) {\r\n           return \"Updating a user...\";\r\n        }\r\n\r\n        @Delete(\"/users/:id\")\r\n        remove(@Param(\"id\") id: number) {\r\n           return \"Removing user...\";\r\n        }\r\n\r\n    }\r\n    ```\r\n\r\n    This class will register routes specified in method decorators in your server framework (express.js or koa).\r\n\r\n2. Create a file `app.ts`\r\n\r\n    ```javascript\r\n    import \"es6-shim\"; // this shim is optional if you are using old version of node\r\n    import \"reflect-metadata\"; // this shim is required\r\n    import {createExpressServer} from \"routing-controllers\";\r\n    import \"./UserController\";  // we need to \"load\" our controller before call createServer. this is required\r\n    let app = createExpressServer(); // creates express app, registers all controller routes and returns you express app instance\r\n    app.listen(3000); // run express application\r\n    ```\r\n\r\n    > koa users just need to call `createKoaServer` instead of `createExpressServer`\r\n\r\n3. Open in browser `http://localhost:3000/users`. You should see `This action returns all users` in your browser.\r\nIf you open `http://localhost:3000/users/1` you should see `This action returns user #1` in your browser.\r\n\r\n## More usage examples\r\n\r\n#### Return promises\r\n\r\nYou can return a promise in the controller, and it will wait until promise resolved and return in a response a promise result.\r\n\r\n```javascript\r\nimport {JsonController, Param, Body, Get, Post, Put, Delete} from \"routing-controllers\";\r\n\r\n@JsonController()\r\nexport class UserController {\r\n\r\n    @Get(\"/users\")\r\n    getAll() {\r\n       return userRepository.findAll();\r\n    }\r\n\r\n    @Get(\"/users/:id\")\r\n    getOne(@Param(\"id\") id: number) {\r\n       return userRepository.findById(id);\r\n    }\r\n\r\n    @Post(\"/users\")\r\n    post(@Body() user: User) {\r\n       return userRepository.insert(user);\r\n    }\r\n\r\n    @Put(\"/users/:id\")\r\n    put(@Param(\"id\") id: number, @Body() user: User) {\r\n       return userRepository.updateById(id, user);\r\n    }\r\n\r\n    @Delete(\"/users/:id\")\r\n    remove(@Param(\"id\") id: number) {\r\n       return userRepository.removeById(id);\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### Using Request and Response objects\r\n\r\nYou can use framework's request and response objects this way:\r\n\r\n```javascript\r\nimport {Controller, Req, Res, Get} from \"routing-controllers\";\r\n\r\n@Controller()\r\nexport class UserController {\r\n\r\n    @Get(\"/users\")\r\n    getAll(@Req() request: any, @Res() response: any) {\r\n        response.send(\"Hello response!\");\r\n    }\r\n\r\n}\r\n```\r\n\r\n`@Req()` decorator inject you a `Request` object, and `@Res()` decorator inject you a `Response` object.\r\nIf you have installed a express typings too, you can use their types:\r\n\r\n```javascript\r\nimport {Request, Response} from \"express\";\r\nimport {Controller, Req, Res, Get} from \"routing-controllers\";\r\n\r\n@Controller()\r\nexport class UserController {\r\n\r\n    @Get(\"/users\")\r\n    getAll(@Req() request: Request, @Res() response: Response) {\r\n        response.send(\"Hello response!\");\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### Using exist server instead of creating a new one\r\n\r\nIf you have, or if you want to create and configure express app separately,\r\nyou can use `useExpressServer` instead of `createExpressServer` function:\r\n\r\n```javascript\r\nimport \"reflect-metadata\"; // this shim is required\r\nimport {useExpressServer} from \"routing-controllers\";\r\n\r\nlet express = require(\"express\"); // or you can import it if you have installed typings\r\nlet app = express(); // your created express server\r\n// app.use() // maybe you configure it the way you want\r\nuseExpressServer(app); // register created express server in routing-controllers\r\napp.listen(3000); // run your express server\r\n```\r\n\r\n> koa users must use `useKoaServer` instead of `useExpressServer`\r\n\r\n#### Load all controllers from the given directory\r\n\r\nYou can load all controllers in once from specific directories, by specifying array of directories via options in\r\n`createExpressServer` or `useExpressServer`:\r\n\r\n```javascript\r\nimport \"reflect-metadata\"; // this shim is required\r\nimport {createExpressServer} from \"routing-controllers\";\r\n\r\ncreateExpressServer({\r\n    controllers: [__dirname + \"/controllers/*.js\"]\r\n}).listen(3000); // register controllers routes in our express application\r\n```\r\n\r\n> koa users must use `createKoaServer` instead of `createExpressServer`\r\n\r\n#### Load all controllers from the given directory and prefix routes\r\n\r\nIf you want to prefix all routes in some directory eg. /api \r\n\r\n```javascript\r\nimport \"reflect-metadata\"; // this shim is required\r\nimport {createExpressServer} from \"routing-controllers\";\r\n\r\ncreateExpressServer({\r\n    routePrefix: \"/api\",\r\n    controllers: [__dirname + \"/api/controllers/*.js\"] // register controllers routes in our express app\r\n}).listen(3000);\r\n```\r\n\r\n> koa users must use `createKoaServer` instead of `createExpressServer`\r\n\r\n#### Prefix controller with base route\r\n\r\nYou can prefix all controller's actions with specific base route:\r\n\r\n```javascript\r\n@Controller(\"/users\")\r\nexport class UserController {\r\n    // ...\r\n}\r\n```\r\n\r\n#### Using JSON instead of regular text content\r\n\r\nIf you are designing a REST API where your endpoints always receive and return JSON you can use `@JsonController` decorator instead\r\nof `@Controller`. This will guarantee you that data returned by your controller actions always be transformed to JSON\r\n and `Content-Type` header will be always set to `application/json`. It will also guarantee that the `application/json` header is understood from the requests and the body parsed as JSON:\r\n\r\n```javascript\r\n@JsonController()\r\nexport class UserController {\r\n    // ...\r\n}\r\n```\r\n\r\n#### Per-action JSON / non-JSON output\r\n\r\nIn the case if you want to control if your controller's action will return json or regular plain text,\r\nyou can specify a special option:\r\n\r\n```javascript\r\n// this will ignore @Controller if it used and return a json in a response\r\n@Get(\"/users\")\r\n@JsonResponse()\r\ngetUsers() {\r\n}\r\n\r\n// this will ignore @JsonController if it used and return a regular text in a response\r\n@Get(\"/posts\")\r\n@TextResponse()\r\ngetPosts() {\r\n}\r\n```\r\n\r\n#### Inject routing parameters\r\n\r\nYou can use parameters in your routes, and to inject such parameters in your controller methods use `@Param` decorator:\r\n\r\n```javascript\r\n@Get(\"/users/:id\")\r\ngetUsers(@Param(\"id\") id: number) {\r\n}\r\n```\r\n\r\n#### Inject query parameters\r\n\r\nTo inject query parameters, use `@QueryParam` decorator:\r\n\r\n```javascript\r\n@Get(\"/users\")\r\ngetUsers(@QueryParam(\"limit\") limit: number) {\r\n}\r\n```\r\n\r\n#### Inject request body\r\n\r\nTo inject request body, use `@Body` decorator:\r\n\r\n```javascript\r\n@Post(\"/users\")\r\nsaveUser(@Body() user: User) {\r\n}\r\n```\r\n\r\nIf you specify a class type to parameter that is decorated with `@Body()`,\r\nrouting-controllers will use [class-transformer][4] to create instance of the given class type with the data received in request body.\r\nTo disable this behaviour you need to specify a `{ useClassTransformer: false }` in RoutingControllerOptions when creating a server.\r\n\r\n\r\n#### Inject request body parameters\r\n\r\nTo inject request body parameter, use `@BodyParam` decorator:\r\n\r\n```javascript\r\n@Post(\"/users\")\r\nsaveUser(@BodyParam(\"name\") userName: string) {\r\n}\r\n```\r\n\r\n#### Inject request header parameters\r\n\r\nTo inject request header parameter, use `@HeaderParam` decorator:\r\n\r\n```javascript\r\n@Post(\"/users\")\r\nsaveUser(@HeaderParam(\"authorization\") token: string) {\r\n}\r\n```\r\n\r\n#### Inject session object\r\n\r\nTo inject a whole session object, use `@Session` decorator:\r\n\r\n```javascript\r\n@Post(\"/login/\")\r\nloginUser(@Session() session: Express.Session, @Body() user: User) {\r\n}\r\n```\r\n\r\nTo inject a single object from session, use `@Session` decorator with parameter:\r\n\r\n```javascript\r\n@Get(\"/login/\")\r\nsavePost(@Session(\"user\") user: User, @Body() post: Post) {\r\n}\r\n```\r\n\r\nExpress uses [express-session][5] / Koa uses [koa-session][6] or [koa-generic-session][7] to handle session, so firstly you have to install it manually to use `@Session` decorator.\r\n\r\n#### Inject state object\r\n\r\nTo inject a whole state object, use `@State` decorator:\r\n\r\n```javascript\r\n@Post(\"/login/\")\r\nloginUser(@State() state: StateType, @Body() user: User) {\r\n}\r\n```\r\n\r\nTo inject a single object from state, use `@State` decorator with parameter:\r\n\r\n```javascript\r\n@Get(\"/login/\")\r\nsavePost(@State(\"user\") user: User, @Body() post: Post) {\r\n}\r\n```\r\n\r\nThis feature is not supported by express driver yet.\r\n\r\n#### Inject uploaded file\r\n\r\nTo inject uploaded file, use `@UploadedFile` decorator:\r\n\r\n```javascript\r\n@Post(\"/files\")\r\nsaveFile(@UploadedFile(\"fileName\") file: any) {\r\n}\r\n```\r\n\r\nRouting-controllers uses [multer][3] to handle file uploads.\r\nYou can install multer's file definitions via typings, and use `files: File[]` type instead of `any[]`.\r\n\r\n#### Inject uploaded files\r\n\r\nTo inject all uploaded files, use `@UploadedFiles` decorator:\r\n\r\n```javascript\r\n@Post(\"/files\")\r\nsaveAll(@UploadedFiles(\"files\") files: any[]) {\r\n}\r\n```\r\n\r\nRouting-controllers uses [multer][3] to handle file uploads.\r\nYou can install multer's file definitions via typings, and use `files: File[]` type instead of `any[]`.\r\n\r\n#### Inject cookie parameter\r\n\r\nTo get a cookie parameter, use `@CookieParam` decorator:\r\n\r\n```javascript\r\n@Get(\"/users\")\r\ngetUsers(@CookieParam(\"username\") username: string) {\r\n}\r\n```\r\n\r\n#### Make parameter required\r\n\r\nTo make any parameter required, simply pass a `required: true` flag in its options:\r\n\r\n```javascript\r\n@Post(\"/users\")\r\nsave(@Body({ required: true }) user: any) {\r\n    // your method will not be executed if user is not sent in a request\r\n}\r\n```\r\n\r\nSame you can do with all other parameters: @Param, @QueryParam, @BodyParam and others.\r\n\r\n#### Convert parameters to objects\r\n\r\nIf you specify a class type to parameter that is decorated with parameter decorator,\r\nrouting-controllers will use [class-transformer][4] to create instance of that class type.\r\nMore info about this feature is available [here](#creating-instances-of-classes-from-action-params).\r\n\r\n#### Set custom ContentType\r\n\r\nYou can specify a custom ContentType:\r\n\r\n```javascript\r\n@Get(\"/users\")\r\n@ContentType(\"text/cvs\")\r\ngetUsers() {\r\n    // ...\r\n}\r\n```\r\n#### Set Location\r\n\r\nYou can set a location for any action:\r\n\r\n```javascript\r\n@Get(\"/users\")\r\n@Location(\"http://github.com\")\r\ngetUsers() {\r\n    // ...\r\n}\r\n```\r\n\r\n#### Set Redirect\r\n\r\nYou can set a redirect for any action:\r\n\r\n```javascript\r\n@Get(\"/users\")\r\n@Redirect(\"http://github.com\")\r\ngetUsers() {\r\n    // ...\r\n}\r\n```\r\n\r\n#### Set custom HTTP code\r\n\r\nYou can explicitly set a returned HTTP code for any action:\r\n\r\n```javascript\r\n@HttpCode(201)\r\n@Post(\"/users\")\r\nsaveUser(@Body() user: User) {\r\n    // ...\r\n}\r\n```\r\n\r\nAlso, there are several additional decorators, that sets conditional http code:\r\n\r\n```javascript\r\n@Get(\"/users/:id\")\r\n@EmptyResultCode(404)\r\nsaveUser(@Param(\"id\") id: number) {\r\n    return userRepository.findOneById(id);\r\n}\r\n```\r\n\r\nIn this example `findOneById` returns undefined in the case if user with given was not found.\r\nThis action will return 404 in the case if user was not found, and regular 200 in the case if it was found.\r\n`@EmptyResultCode` allows to set any HTTP code in the case if controller's action returned empty result (null or undefined).\r\nThere are also `@NullResultCode` and `@UndefindeResultCode()` in the case if you want to return specific codes only\r\nif controller's action returned null or undefined respectively.\r\n\r\n#### Set custom headers\r\n\r\nYou can set any custom header in a response:\r\n\r\n```javascript\r\n@Get(\"/users/:id\")\r\n@Header(\"Cache-Control\", \"none\")\r\ngetOne(@Param(\"id\") id: number) {\r\n    // ...\r\n}\r\n```\r\n#### Render templates\r\n\r\nYou can set any custom header in a response:\r\n\r\n```javascript\r\n@Get(\"/users/:id\")\r\n@Render(\"index.html\")\r\ngetOne() {\r\n    return {\r\n        param1: \"these params are used\",\r\n        param2: \"in templating engine\"\r\n    };\r\n}\r\n```\r\n\r\nTo use rendering ability make sure to configure express properly.\r\n[Here](https://github.com/pleerock/routing-controllers/blob/0.6.0-release/test/functional/render-decorator.spec.ts)\r\nis a test where you can take a look how to do it.\r\n\r\nTo use rendering ability with Koa you will need to use a rendering 3rd party such as [koa-views](https://github.com/queckezz/koa-views/), \r\nkoa-views is the only render middleware that has been tested.\r\n\r\n## Using middlewares\r\n\r\nYou can use any exist express / koa middleware, or create your own.\r\nTo create your middlewares there is a `@Middleware` decorator,\r\nand to use already exist middlewares there are `@UseBefore` and `@UseAfter` decorators.\r\n\r\n### Use exist middleware\r\n\r\nThere are multiple ways to use middlewares.\r\nFor example, lets try to use [compression](https://github.com/expressjs/compression) middleware:\r\n\r\n1. Install compression middleware: `npm install compression`\r\n2. To use middleware per-action:\r\n\r\n    ```javascript\r\n    import {Controller, Get, UseBefore} from \"routing-controllers\";\r\n    let compression = require(\"compression\");\r\n\r\n    // ...\r\n\r\n    @Get(\"/users/:id\")\r\n    @UseBefore(compression())\r\n    getOne(@Param(\"id\") id: number) {\r\n        // ...\r\n    }\r\n    ```\r\n\r\n    This way compression middleware will be applied only for `getOne` controller action,\r\n    and will be executed *before* action execution.\r\n    To execute middleware *after* action use `@UseAfter` decorator instead.\r\n\r\n3. To use middleware per-controller:\r\n\r\n    ```javascript\r\n    import {Controller, UseBefore} from \"routing-controllers\";\r\n    let compression = require(\"compression\");\r\n\r\n    @Controller()\r\n    @UseBefore(compression())\r\n    export class UserController {\r\n\r\n    }\r\n    ```\r\n\r\n    This way compression middleware will be applied for all actions of the `UserController` controller,\r\n    and will be executed *before* its action execution. Same way you can use `@UseAfter` decorator here.\r\n\r\n4. If you want to use compression module globally for all controllers you can simply register it during bootstrap:\r\n\r\n    ```javascript\r\n    import \"reflect-metadata\";\r\n    import {createExpressServer} from \"routing-controllers\";\r\n    import \"./UserController\";  // we need to \"load\" our controller before call createExpressServer. this is required\r\n    let compression = require(\"compression\");\r\n    let app = createExpressServer(); // creates express app, registers all controller routes and returns you express app instance\r\n    app.use(compression());\r\n    app.listen(3000); // run express application\r\n    ```\r\n\r\n    Alternatively, you can create a custom [global middleware](#global-middlewares) and simply delegate its execution to the compression module.\r\n\r\n### Creating your own express middleware\r\n\r\nHere is example of creating middleware for express.js:\r\n\r\n1. To create your own middleware you need to create a class that implements a `MiddlewareInterface` interface and decorated\r\nwith `@Middleware` decorator:\r\n\r\n    ```javascript\r\n    import {Middleware, MiddlewareInterface} from \"routing-controllers\";\r\n\r\n    @Middleware()\r\n    export class MyMiddleware implements MiddlewareInterface {\r\n\r\n        use(request: any, response: any, next?: (err?: any) => any): any {\r\n            console.log(\"do something...\");\r\n            next();\r\n        }\r\n\r\n    }\r\n    ```\r\n\r\n    Here, we created our own middleware that prints `do something...` in the console.\r\n\r\n2. Second we need to load our middleware in `app.ts` before app bootstrap:\r\n\r\n    ```javascript\r\n    import \"reflect-metadata\";\r\n    import {createExpressServer} from \"routing-controllers\";\r\n    import \"./UserController\";\r\n    import \"./MyMiddleware\"; // here we load it\r\n    createExpressServer().listen(3000);\r\n    ```\r\n\r\n3. Now we can use our middleware:\r\n\r\n    ```javascript\r\n    import {Controller, UseBefore} from \"routing-controllers\";\r\n    import {MyMiddleware} from \"./MyMiddleware\";\r\n\r\n    @Controller()\r\n    @UseBefore(MyMiddleware)\r\n    export class UserController {\r\n\r\n    }\r\n    ```\r\n\r\n    or per-action:\r\n\r\n    ```javascript\r\n    @Get(\"/users/:id\")\r\n    @UseBefore(MyMiddleware)\r\n    getOne(@Param(\"id\") id: number) {\r\n        // ...\r\n    }\r\n    ```\r\n\r\n    This way your middleware will be executed each time before controller action.\r\n    You can use `@UseAfter(MyMiddleware)` to make it execute after each controller action.\r\n\r\n### Creating your own koa middleware\r\n\r\nHere is example of creating middleware for koa.js:\r\n\r\n1. To create your own middleware you need to create a class that implements a `MiddlewareInterface` interface and decorated\r\nwith `@Middleware` decorator:\r\n\r\n    ```javascript\r\n    import {Middleware, MiddlewareInterface} from \"routing-controllers\";\r\n\r\n    @Middleware()\r\n    export class MyMiddleware implements MiddlewareInterface {\r\n\r\n        use(context: any, next: (err: any) => Promise<any>): Promise<any> {\r\n            console.log(\"do something before execution...\");\r\n            return next().then(() => {\r\n                console.log(\"do something after execution\");\r\n            }).catch(error => {\r\n                console.log(\"error handling is also here\");\r\n            });\r\n        }\r\n\r\n    }\r\n    ```\r\n\r\n    Here, we created our own middleware that prints `do something...` in the console.\r\n\r\n2. Second we need to load our middleware in `app.ts` before app bootstrap:\r\n\r\n    ```javascript\r\n    import \"reflect-metadata\";\r\n    import {createKoaServer} from \"routing-controllers\";\r\n    import \"./UserController\";\r\n    import \"./MyMiddleware\"; // here we load it\r\n    createKoaServer().listen(3000);\r\n    ```\r\n\r\n3. Now we can use our middleware:\r\n\r\n    ```javascript\r\n    import {Controller, UseBefore} from \"routing-controllers\";\r\n    import {MyMiddleware} from \"./MyMiddleware\";\r\n\r\n    @Controller()\r\n    @UseBefore(MyMiddleware)\r\n    export class UserController {\r\n\r\n    }\r\n    ```\r\n\r\n    or per-action:\r\n\r\n    ```javascript\r\n    @Get(\"/users/:id\")\r\n    @UseBefore(MyMiddleware)\r\n    getOne(@Param(\"id\") id: number) {\r\n        // ...\r\n    }\r\n    ```\r\n\r\n    This way your middleware will be executed each time before controller action.\r\n    You can use `@UseAfter(MyMiddleware)` to make it execute after each controller action.\r\n\r\n### Global middlewares\r\n\r\nSame way you created a middleware, you can create a global middleware:\r\n\r\n```javascript\r\nimport {MiddlewareGlobalBefore, MiddlewareInterface} from \"routing-controllers\";\r\n\r\n@MiddlewareGlobalBefore()\r\nexport class CompressionMiddleware implements MiddlewareInterface {\r\n\r\n    use(request: any, response: any, next: (err: any) => any): void {\r\n        let compression = require(\"compression\");\r\n        return compression()(request, response, next);\r\n    }\r\n\r\n}\r\n```\r\nIn this example we simply delegate middleware to compression to use it globally.\r\nGlobal middleware runs before each request, always.\r\n\r\nYou can make global middleware to run after controller action by using `@MiddlewareGlobalAfter` instead of `@MiddlewareGlobalBefore`.\r\n If you have issues with global middlewares run execution order you can set a priority: `@MiddlewareGlobalBefore({ priority: 1 })`.\r\n Higher priority means middleware being executed earlier.\r\n\r\n### Error handlers\r\n\r\nError handlers are specific only to express.\r\nError handlers work in pretty much the same way as middlewares, but implement `ErrorMiddlewareInterface` instead of `MiddlewareInterface`:\r\n\r\n1. Create a class that implements the `ErrorMiddlewareInterface` interface and is decorated with the `@MiddlewareGlobalAfter` decorator:\r\n\r\n    ```javascript\r\n    import {ErrorMiddlewareInterface, MiddlewareGlobalAfter} from \"routing-controllers\";\r\n\r\n    @MiddlewareGlobalAfter()\r\n    export class CustomErrorHandler implements ErrorMiddlewareInterface {\r\n\r\n        error(error: any, request: any, response: any, next: (err: any) => any) {\r\n            console.log(\"do something...\");\r\n            next();\r\n        }\r\n\r\n    }\r\n    ```\r\nCustom error handlers are invoked after the default error handler, so you won't be able to change response code or headers.\r\nTo prevent this, you have to disable default error handler by specyfing `defaultErrorHandler` option in createExpressServer or useExpressServer:\r\n\r\n```javascript\r\ncreateExpressServer({\r\n    defaultErrorHandler: false // disable default error handler, only if you have your own error handler\r\n}).listen(3000);\r\n```\r\n\r\n## Using interceptors\r\n\r\nInterceptors are used to change or replace the data returned to the client.\r\nYou can create your own interceptor class or function and use to all or specific controller or controller action.\r\nIt works pretty much the same as middlewares.\r\n\r\n### Interceptor function\r\n\r\nThe easiest way is to use functions directly passed to `@UseInterceptor` of the action. \r\n\r\n```javascript\r\nimport {Get, Param, UseInterceptor} from \"routing-controllers\";\r\n\r\n// ...\r\n\r\n@Get(\"/users\")\r\n@UseInterceptor(function(request: any, response: any, content: any) {\r\n    // here you have content returned by this action. you can replace something \r\n    // in it and return a replaced result. replaced result will be returned to the user\r\n    return content.replace(/Mike/gi, \"Michael\");\r\n})\r\ngetOne(@Param(\"id\") id: number) {\r\n    return \"Hello, I am Mike!\"; // client will get a \"Hello, I am Michael!\" response.\r\n}\r\n```\r\n\r\nYou can use `@UseInterceptor` per-action, on per-controller. \r\nIf its used per-controller then interceptor will apply to all controller actions.\r\n\r\n### Interceptor classes\r\n\r\nYou can also create a class and use it with `@UseInterceptor` decorator:\r\n\r\n```javascript\r\nimport {Interceptor, InterceptorInterface} from \"routing-controllers\";\r\n\r\n@Interceptor()\r\nexport class NameCorrectionInterceptor implements InterceptorInterface {\r\n    \r\n    intercept(request: any, response: any, content: any) {\r\n        return content.replace(/Mike/gi, \"Michael\");\r\n    }\r\n    \r\n}\r\n```\r\n\r\nAnd use it in your controllers this way:\r\n\r\n```javascript\r\nimport {Get, Param, UseInterceptor} from \"routing-controllers\";\r\nimport {NameCorrectionInterceptor} from \"./NameCorrectionInterceptor\";\r\n\r\n// ...\r\n\r\n@Get(\"/users\")\r\n@UseInterceptor(NameCorrectionInterceptor)\r\ngetOne(@Param(\"id\") id: number) {\r\n    return \"Hello, I am Mike!\"; // client will get a \"Hello, I am Michael!\" response.\r\n}\r\n```\r\n\r\n### Global interceptors\r\n\r\nYou can create interceptors that will affect all controllers in your project by creating interceptor class\r\nand mark it with `@InterceptorGlobal` decorator:\r\n\r\n```javascript\r\nimport {InterceptorGlobal, InterceptorInterface} from \"routing-controllers\";\r\n\r\n@InterceptorGlobal()\r\nexport class NameCorrectionInterceptor implements InterceptorInterface {\r\n    \r\n    intercept(request: any, response: any, content: any) {\r\n        return content.replace(/Mike/gi, \"Michael\");\r\n    }\r\n    \r\n}\r\n```\r\n\r\n### Don't forget to load your middlewares, error handlers and interceptors\r\n\r\nMiddlewares and error handlers should be loaded globally the same way as controllers, before app bootstrap:\r\n\r\n```javascript\r\nimport \"reflect-metadata\";\r\nimport {createExpressServer} from \"routing-controllers\";\r\nimport \"./UserController\";\r\nimport \"./MyMiddleware\"; // here we load it\r\nimport \"./CustomErrorHandler\"; // here we load it\r\nimport \"./BadWordInterceptor\"; // here we load it\r\nlet app = createExpressServer();\r\napp.listen(3000);\r\n```\r\n\r\nAlso you can load middlewares from directories. Also you can use glob patterns:\r\n\r\n```javascript\r\nimport \"reflect-metadata\";\r\nimport {createExpressServer} from \"routing-controllers\";\r\ncreateExpressServer({\r\n    controllers: [__dirname + \"/controllers/**/*.js\"],\r\n    middlewares: [__dirname + \"/middlewares/**/*.js\"]\r\n}).listen(3000);\r\n```\r\n\r\n## Creating instances of classes from action params\r\n\r\nWhen user sends a json object and you are parsing it, sometimes you want to parse it into object of some class, instead of parsing it into simple literal object.\r\nYou have ability to do this using [class-transformer][4].\r\nTo use it simply specify a `useClassTransformer: true` option on application bootstrap:\r\n\r\n```javascript\r\nimport \"reflect-metadata\";\r\nimport {createExpressServer} from \"routing-controllers\";\r\n\r\ncreateExpressServer({\r\n    useClassTransformer: true\r\n}).listen(3000);\r\n```\r\n\r\nNow, when you parse your action params, if you have specified a class, routing-controllers will create you a class\r\nof that instance with the data sent by a user:\r\n\r\n```javascript\r\nexport class User {\r\n    firstName: string;\r\n    lastName: string;\r\n\r\n    getName(): string {\r\n        return this.lastName + \" \" + this.firstName;\r\n    }\r\n}\r\n\r\n@Controller()\r\nexport class UserController {\r\n\r\n    post(@Body() user: User) {\r\n        console.log(\"saving user \" + user.getName());\r\n    }\r\n\r\n}\r\n```\r\n\r\nIf `User` is an interface - then simple literal object will be created. If its a class - then instance of this will be created.\r\n\r\nThis technique works not only with `@Body`, but also with `@Param`, `@QueryParam`, `@BodyParam` and other decorators.\r\nLearn more about class-transformer and how to handle more complex object constructions [here][4].\r\nThis behaviour is enabled by default.\r\nIf you want to disable it simply pass `useClassTransformer: false` to createExpressServer method.\r\n\r\n## Auto validating action params\r\n\r\nSometimes parsing a json object into instance of some class is not enough. \r\nE.g. `class-transformer` doesn't check whether the property's types are correct, so you can get runtime error if you rely on TypeScript type safe. Also you may want to validate the object to check e.g. whether the password string is long enough or entered e-mail is correct.\r\n\r\nIt can be done easily thanks to integration with [class-validator][9]. All you need to do is simply specify a `enableValidation: true` option on application bootstrap:\r\n```javascript\r\nimport \"reflect-metadata\";\r\nimport { createExpressServer } from \"routing-controllers\";\r\n\r\ncreateExpressServer({\r\n    enableValidation: true\r\n}).listen(3000);\r\n```\r\n\r\nIf you don't want to turn on the validation globally for every parameter, you can do this locally by setting `validate: true` option in parameter decorator options object:\r\n```javascript\r\n@Post(\"/login/\")\r\nlogin(@Body({ validate: true }) user: User) {\r\n```\r\n\r\nNow you need to define the class which type will be used in controller method params. Decorate the properties with appropriate validation decorators.\r\n```javascript\r\nexport class User {\r\n\r\n    @IsEmail()\r\n    email: string;\r\n\r\n    @MinLength(6)\r\n    password: string;\r\n\r\n}\r\n```\r\nIf you haven't used class-validator yet, you can learn how to use the decorators and handle more complex object validation [here][9].\r\n\r\nNow, if you have specified a class type, your action params will be not only an instance of that class (with the data sent by a user) but they will be validated too, so you don't have to worry about eg. incorrect e-mail or too short password and manual checks every property in controller method body.\r\n```javascript\r\n@Controller()\r\nexport class UserController {\r\n\r\n    @Post(\"/login/\")\r\n    login(@Body() user: User) {\r\n        console.log(`${user.email} is for 100% sure a valid e-mail adress!`);\r\n        console.log(`${user.password.length} is for 100% sure 6 chars or more!`);\r\n    }\r\n\r\n}\r\n```\r\nIf the param doesn't satisfy the requirements defined by class-validator decorators, an error will be throwed and captured by routing-controller, so the client will receive 400 Bad Request and JSON with nice detailed [Validation errors](https://github.com/pleerock/class-validator#validation-errors) array.\r\n\r\nIf you need special options for validation (groups, skiping missing properties, etc.) or transforming (groups, excluding prefixes, versions, etc.) you can pass them as global config as `validationOptions ` in createExpressServer method or as a local setting for method parameter - `@Body({validationOptions: localOptions})`.\r\n\r\nThis technique works not only with `@Body` but also with `@Param`, `@QueryParam`, `@BodyParam` and other decorators.\r\nThis behaviour is **disabled** by default. If you want to enable it, you need to do it explicitly eg. by passing `enableValidation: true` to createExpressServer method.\r\n\r\n## Default error handling\r\n\r\nRouting-controller comes with default error handling mechanism.\r\n\r\n## Using DI container\r\n\r\n`routing-controllers` supports a DI container out of the box. You can inject your services into your controllers,\r\nmiddlewares and error handlers. Container must be setup during application bootstrap.\r\nHere is example how to integrate routing-controllers with [typedi](https://github.com/pleerock/typedi):\r\n\r\n```javascript\r\nimport \"reflect-metadata\";\r\nimport {createExpressServer, useContainer} from \"routing-controllers\";\r\nimport {Container} from \"typedi\";\r\n\r\n// its important to set container before any operation you do with routing-controllers,\r\n// including importing controllers\r\nuseContainer(Container);\r\n\r\n// create and run server\r\ncreateExpressServer({\r\n    controllers: [__dirname + \"/controllers/*.js\"],\r\n    middlewares: [__dirname + \"/middlewares/*.js\"],\r\n    interceptors: [__dirname + \"/interceptor/*.js\"],\r\n}).listen(3000);\r\n```\r\n\r\nThat's it, now you can inject your services into your controllers:\r\n\r\n```javascript\r\n@Controller()\r\nexport class UsersController {\r\n\r\n    constructor(private userRepository: UserRepository) {\r\n    }\r\n\r\n    // ... controller actions\r\n\r\n}\r\n```\r\n\r\n## Decorators Reference\r\n\r\n#### Controller Decorators\r\n\r\n| Signature                            | Example                                              | Description                                                                                                                                                                                                                                                                                                                                                                                                                                          |\r\n|--------------------------------------|------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| `@Controller(baseRoute: string)`     | `@Controller(\"/users\") class SomeController`         | Class that is marked with this decorator is registered as controller and its annotated methods are registered as actions. Base route is used to concatenate it to all controller action routes.                                                                                                                                                                                                                                                     |\r\n| `@JsonController(baseRoute: string)` | `@JsonController(\"/users\") class SomeJsonController` | Class that is marked with this decorator is registered as controller and its annotated methods are registered as actions. Difference between @JsonController and @Controller is that @JsonController automatically converts results returned by controller to json objects (using JSON.parse) and response being sent to a client is sent with application/json content-type. Base route is used to concatenate it to all controller action routes. |\r\n\r\n#### Controller Method Decorators\r\n\r\n| Signature                                                                    | Example                                | Description                                                                                                                                                                                                       | express.js analogue                  |\r\n|------------------------------------------------------------------------------|----------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|\r\n| `@Get(route: string|RegExp)`                                                 | `@Get(\"/users\") all()`                 | Methods marked with this decorator will register a request made with GET HTTP Method to a given route. In action options you can specify if action should response json or regular text response.                 | `app.get(\"/users\", all)`             |\r\n| `@Post(route: string|RegExp)`                                                | `@Post(\"/users\") save()`               | Methods marked with this decorator will register a request made with POST HTTP Method to a given route. In action options you can specify if action should response json or regular text response.                | `app.post(\"/users\", save)`           |\r\n| `@Put(route: string|RegExp)`                                                 | `@Put(\"/users/:id\") update()`          | Methods marked with this decorator will register a request made with PUT HTTP Method to a given route. In action options you can specify if action should response json or regular text response.                 | `app.put(\"/users\", update)`          |\r\n| `@Patch(route: string|RegExp)`                                               | `@Patch(\"/users/:id\") patch()`         | Methods marked with this decorator will register a request made with PATCH HTTP Method to a given route. In action options you can specify if action should response json or regular text response.               | `app.patch(\"/users/:id\", patch)`     |\r\n| `@Delete(route: string|RegExp)`                                              | `@Delete(\"/users/:id\") delete()`       | Methods marked with this decorator will register a request made with DELETE HTTP Method to a given route. In action options you can specify if action should response json or regular text response.              | `app.delete(\"/users/:id\", delete)`   |\r\n| `@Head(route: string|RegExp)`                                                | `@Head(\"/users/:id\") head()`           | Methods marked with this decorator will register a request made with HEAD HTTP Method to a given route. In action options you can specify if action should response json or regular text response.                | `app.head(\"/users/:id\", head)`       |\r\n| `@Options(route: string|RegExp)`                                             | `@Options(\"/users/:id\") head()`        | Methods marked with this decorator will register a request made with OPTIONS HTTP Method to a given route. In action options you can specify if action should response json or regular text response.             | `app.options(\"/users/:id\", options)` |\r\n| `@Method(methodName: string, route: string|RegExp)`                          | `@Method(\"move\", \"/users/:id\") move()` | Methods marked with this decorator will register a request made with given `methodName` HTTP Method to a given route. In action options you can specify if action should response json or regular text response.  | `app.move(\"/users/:id\", move)`       |\r\n\r\n#### Method Parameter Decorators\r\n\r\n| Signature                                                          | Example                                          | Description                                                                                                                                                                                                                                                                  | express.js analogue                       |\r\n|--------------------------------------------------------------------|--------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------|\r\n| `@Req()`                                                           | `getAll(@Req() request: Request)`                | Injects a Request object to a controller action parameter value                                                                                                                                                                                                              | `function (request, response)`            |\r\n| `@Res()`                                                           | `getAll(@Res() response: Response)`              | Injects a Reponse object to a controller action parameter value                                                                                                                                                                                                              | `function (request, response)`            |\r\n| `@Body(options?: ParamOptions)`                                    | `post(@Body() body: any)`                        | Injects a body to a controller action parameter value. In options you can specify if body should be parsed into a json object or not. Also you can specify there if body is required and action cannot work without body being specified.                                    | `request.body`                            |\r\n| `@Param(name: string, options?: ParamOptions)`                     | `get(@Param(\"id\") id: number)`                   | Injects a parameter to a controller action parameter value. In options you can specify if parameter should be parsed into a json object or not. Also you can specify there if parameter is required and action cannot work with empty parameter.                             | `request.params.id`                       |\r\n| `@Session(objectName: string, options?: ParamOptions)`             | `get(@Session(\"user\") user: User)`               | Injects an object from session to a controller action parameter value. In options you can specify there if parameter is not required and action can work with empty parameter.                             | `request.session.user`                       |\r\n| `@Session()`                                                       | `get(@Session() session: express.Session)`       | Injects a whole session object to a controller action parameter value. A session object is required and action cannot work with empty parameter.                             | `request.session`                       |\r\n| `@State(objectName: string, options?: ParamOptions)`             | `get(@State(\"user\") user: User)`               | Injects an object from state to a controller action parameter value. In options you can specify there if parameter is not required and action can work with empty parameter.                             | `ctx.state.user`                       |\r\n| `@State()`                                                       | `get(@State() session: StateType)`       | Injects a whole state object to a controller action parameter value. A state object is required and action cannot work with empty parameter.                             | `ctx.state`                       |\r\n| `@QueryParam(name: string, options?: ParamOptions)`                | `get(@QueryParam(\"id\") id: number)`              | Injects a query string parameter to a controller action parameter value. In options you can specify if parameter should be parsed into a json object or not. Also you can specify there if query parameter is required and action cannot work with empty parameter.          | `request.query.id`                        |\r\n| `@HeaderParam(name: string, options?: ParamOptions)`               | `get(@HeaderParam(\"token\") token: string)`       | Injects a parameter from response headers to a controller action parameter value. In options you can specify if parameter should be parsed into a json object or not. Also you can specify there if query parameter is required and action cannot work with empty parameter. | `request.headers.token`                   |\r\n| `@UploadedFile(name: string, options?: { required?: boolean })`    | `post(@UploadedFile(\"files\") file: any)`         | Injects a \"file\" from the response to a controller action parameter value. In parameter options you can specify if this is required parameter or not. parseJson option is ignored                                                                                            | `request.file.file` (when using multer)   |\r\n| `@UploadedFiles(options?: ParamOptions)`                           | `post(@UploadedFiles() files: any[])`            | Injects all uploaded files from the response to a controller action parameter value. In parameter options you can specify if this is required parameter or not. parseJson option is ignored                                                                                  | `request.files` (when using multer)       |\r\n| `@BodyParam(name: string, options?: ParamOptions)`                 | `post(@BodyParam(\"name\") name: string)`          | Injects a body parameter to a controller action parameter value. In options you can specify if parameter should be parsed into a json object or not. Also you can specify there if body parameter is required and action cannot work with empty parameter.                   | `request.body.name`                       |\r\n| `@CookieParam(name: string, options?: ParamOptions)`               | `get(@CookieParam(\"username\") username: string)` | Injects a cookie parameter to a controller action parameter value. In options you can specify if parameter should be parsed into a json object or not. Also you can specify there if cookie parameter is required and action cannot work with empty parameter.               | `request.cookie(\"username\")`              |\r\n\r\n#### Middleware and Interceptor Decorators\r\n\r\n| Signature                                                          | Example                                          | Description                                                                                                     |\r\n|--------------------------------------------------------------------|--------------------------------------------------|-----------------------------------------------------------------------------------------------------------------|\r\n| `@Middleware()`                                                    | `@Middleware() class SomeMiddleware`             | Registers a new middleware.                                                                                     |\r\n| `@MiddlewareGlobalBefore()`                                        | `@MiddlewareGlobalBefore() class SomeMiddleware` | Registers a middleware that runs globally before action execution.                                              |\r\n| `@MiddlewareGlobalAfter()`                                         | `@MiddlewareGlobalAfter() class SomeMiddleware`  | Registers a middleware that runs globally after action execution.                                               |\r\n| `@ErrorHandler()`                                                  | `@ErrorHandler() class SomeErrorHandler`         | Registers a new error handler.                                                                                  |\r\n| `@UseBefore()`                                                     | `@UseBefore(CompressionMiddleware)`              | Uses given middleware before action is being executed.                                                          |\r\n| `@UseAfter()`                                                      | `@UseAfter(CompressionMiddleware)`               | Uses given middleware after action is being executed.                                                           |\r\n| `@Interceptor()`                                                   | `@Interceptor(InterceptorMiddleware)`            | Registers a given class as an interceptor                                                                       |\r\n| `@InterceptorGlobal()`                                             | `@InterceptorGlobal(InterceptorMiddleware)`      | Registers a global interceptor.                                                                                 |\r\n| `@UseInterceptor()`                                                | `@UseInterceptor(InterceptorMiddleware)`         | Uses given interceptor for the given action or controller.                                                      |\r\n\r\n#### Other Decorators\r\n\r\n| Signature                                                          | Example                                           | Description                                                                                                     |\r\n|--------------------------------------------------------------------|---------------------------------------------------|-----------------------------------------------------------------------------------------------------------------|\r\n| `@JsonResponse()`                                                  | `@JsonResponse()` get()                           | Controller actions marked with this decorator will return a json response instead of default text/html.         |\r\n| `@TextResponse()`                                                  | `@TextResponse()` get()                           | Controller actions marked with this decorator will return a text/html response instead of default json.         |\r\n| `@HttpCode(code: number)`                                          | `@HttpCode(201)` post()                           | Allows to explicitly set HTTP code to be returned in the response.                                              |\r\n| `@EmptyResultCode(code: number)`                                   | `@EmptyResultCode(201)` post()                    | Sets a given HTTP code when controller action returned empty result (null or undefined).                        |\r\n| `@NullResultCode(code: number)`                                    | `@NullResultCode(201)` post()                     | Sets a given HTTP code when controller action returned null.                                                    |\r\n| `@UndefinedResultCode(code: number)`                               | `@UndefinedResultCode(201)` post()                | Sets a given HTTP code when controller action returned undefined.                                               |\r\n| `@ResponseClassTransformOptions(options: ClassTransformOptions)`   | `@ResponseClassTransformOptions({/*...*/})` get() | Sets options to be passed to class-transformer when it used for classToPlain a response result.                 |\r\n| `@ContentType(contentType: string)`                                | `@ContentType(\"text/csv\")` get()                  | Allows to explicitly set HTTP Content-type returned in the response.                                            |\r\n| `@Header(contentType: string)`                                     | `@Header(\"Cache-Control\", \"private\")` get()       | Allows to explicitly set any HTTP Header returned in the response.                                              |\r\n| `@Location(url: string)`                                           | `@Location(\"http://github.com\")` get()            | Allows to explicitly set HTTP Location.                                                                         |\r\n| `@Redirect(url: string)`                                           | `@Redirect(\"http://github.com\")` get()            | Allows to explicitly set HTTP Redirect.                                                                         |\r\n| `@Render(template: string)`                                        | `@Render(\"user-list.html\")` get()                 | Renders a given html when user accesses route.                                                                  |\r\n\r\n## Samples\r\n\r\n* Take a look on [routing-controllers with express](https://github.com/pleerock/routing-controllers-express-demo) which is using routing-controllers.\r\n* Take a look on [routing-controllers with koa](https://github.com/pleerock/routing-controllers-koa-demo) which is using routing-controllers.\r\n* Take a look on [routing-controllers with angular 2](https://github.com/pleerock/routing-controllers-angular2-demo) which is using routing-controllers.\r\n* Take a look on [node-microservice-demo](https://github.com/swimlane/node-microservice-demo) which is using routing-controllers.\r\n* Take a look on samples in [./sample](https://github.com/pleerock/routing-controllers/tree/master/sample) for more examples\r\nof usage.\r\n\r\n## Release notes\r\n\r\nSee information about breaking changes and release notes [here](https://github.com/pleerock/routing-controllers/tree/master/doc/release-notes.md).\r\n\r\n[1]: http://expressjs.com/\r\n[2]: http://koajs.com/\r\n[3]: https://github.com/expressjs/multer\r\n[4]: https://github.com/pleerock/class-transformer\r\n[5]: https://www.npmjs.com/package/express-session\r\n[6]: https://www.npmjs.com/package/koa-session\r\n[7]: https://www.npmjs.com/package/koa-generic-session\r\n[8]: http://koajs.com/#ctx-state\r\n[9]: https://github.com/pleerock/class-validator\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/pleerock/routing-controllers.git"
  },
  "scripts": {
    "test": "gulp tests"
  },
  "tags": [
    "express",
    "express.js",
    "typescript",
    "typescript-express",
    "typescript-express.js",
    "express-controllers",
    "controllers"
  ],
  "typings": "index.d.ts",
  "version": "0.6.12"
}
