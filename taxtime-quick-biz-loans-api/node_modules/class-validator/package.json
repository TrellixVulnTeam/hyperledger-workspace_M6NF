{
  "_args": [
    [
      {
        "raw": "class-validator@^0.6.8",
        "scope": null,
        "escapedName": "class-validator",
        "name": "class-validator",
        "rawSpec": "^0.6.8",
        "spec": ">=0.6.8 <0.7.0",
        "type": "range"
      },
      "/home/gunungmerapi/wajid-projects/hyperledger-workspace/taxtime-quick-biz-loans-api/node_modules/routing-controllers"
    ]
  ],
  "_from": "class-validator@>=0.6.8 <0.7.0",
  "_id": "class-validator@0.6.8",
  "_inCache": true,
  "_location": "/class-validator",
  "_nodeVersion": "6.6.0",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/class-validator-0.6.8.tgz_1483814261617_0.8110215414781123"
  },
  "_npmUser": {
    "name": "pleerock",
    "email": "zarrhost@gmail.com"
  },
  "_npmVersion": "3.10.3",
  "_phantomChildren": {},
  "_requested": {
    "raw": "class-validator@^0.6.8",
    "scope": null,
    "escapedName": "class-validator",
    "name": "class-validator",
    "rawSpec": "^0.6.8",
    "spec": ">=0.6.8 <0.7.0",
    "type": "range"
  },
  "_requiredBy": [
    "/routing-controllers"
  ],
  "_resolved": "https://registry.npmjs.org/class-validator/-/class-validator-0.6.8.tgz",
  "_shasum": "af34fa10f99ecb86679d291d73ef8076d9ab8b95",
  "_shrinkwrap": null,
  "_spec": "class-validator@^0.6.8",
  "_where": "/home/gunungmerapi/wajid-projects/hyperledger-workspace/taxtime-quick-biz-loans-api/node_modules/routing-controllers",
  "author": {
    "name": "Umed Khudoiberdiev",
    "email": "pleerock.me@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/pleerock/class-validator/issues"
  },
  "dependencies": {
    "validator": ">=5.0.0"
  },
  "description": "Class-based validation with Typescript / ES6 / ES5 using decorators or validation schemas. Supports both node.js and browser",
  "devDependencies": {
    "@types/chai": "^3.4.34",
    "@types/chai-as-promised": "0.0.29",
    "@types/es6-shim": "^0.31.32",
    "@types/gulp": "^3.8.32",
    "@types/mocha": "^2.2.32",
    "@types/node": "^6.0.45",
    "@types/sinon": "^1.16.31",
    "chai": "^3.4.1",
    "chai-as-promised": "^6.0.0",
    "codecov": "^1.0.1",
    "del": "^2.2.2",
    "es6-shim": "^0.35.1",
    "gulp": "^3.9.1",
    "gulp-istanbul": "^1.1.1",
    "gulp-mocha": "^3.0.1",
    "gulp-replace": "^0.5.4",
    "gulp-shell": "^0.5.0",
    "gulp-sourcemaps": "^1.6.0",
    "gulp-tslint": "^6.1.2",
    "gulp-typescript": "^3.0.2",
    "gulpclass": "0.1.1",
    "mocha": "^3.1.2",
    "remap-istanbul": "^0.7.0",
    "sinon": "^1.17.6",
    "sinon-chai": "^2.8.0",
    "tslint": "^3.15.1",
    "tslint-stylish": "^2.1.0-beta",
    "typescript": "^2.0.3"
  },
  "directories": {},
  "dist": {
    "shasum": "af34fa10f99ecb86679d291d73ef8076d9ab8b95",
    "tarball": "https://registry.npmjs.org/class-validator/-/class-validator-0.6.8.tgz"
  },
  "homepage": "https://github.com/pleerock/class-validator#readme",
  "license": "MIT",
  "maintainers": [
    {
      "name": "pleerock",
      "email": "zarrhost@gmail.com"
    }
  ],
  "name": "class-validator",
  "optionalDependencies": {},
  "private": false,
  "readme": "# class-validator\r\n\r\n[![Build Status](https://travis-ci.org/pleerock/class-validator.svg?branch=master)](https://travis-ci.org/pleerock/class-validator)\r\n[![codecov](https://codecov.io/gh/pleerock/class-validator/branch/master/graph/badge.svg)](https://codecov.io/gh/pleerock/class-validator)\r\n[![npm version](https://badge.fury.io/js/class-validator.svg)](https://badge.fury.io/js/class-validator)\r\n[![Dependency Status](https://david-dm.org/pleerock/class-validator.svg)](https://david-dm.org/pleerock/class-validator)\r\n[![devDependency Status](https://david-dm.org/pleerock/class-validator/dev-status.svg)](https://david-dm.org/pleerock/class-validator#info=devDependencies)\r\n[![Join the chat at https://gitter.im/pleerock/class-validator](https://badges.gitter.im/pleerock/class-validator.svg)](https://gitter.im/pleerock/class-validator?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nAllows use of decorator and non-decorator based validation.\r\nInternally uses [validator.js][1] to perform validation.\r\nClass-validator works on both browser and node.js platforms.\r\n\r\n## Installation\r\n\r\nInstall module:\r\n\r\n`npm install class-validator --save`\r\n\r\n#### Old versions of node.js/browser\r\n\r\nES6 features are used, if you are using old versions of node (or browser) you may want to install [es6-shim](https://github.com/paulmillr/es6-shim) too:\r\n\r\n`npm install es6-shim --save`\r\n\r\nand use it somewhere in the global place of your app:\r\n\r\n* for nodejs: `require(\"es6-shim\")` (or `import \"es6-shim\";`) in your app's entry point (for example in `app.ts`)\r\n* for browser: `<script src=\"node_modules/es6-shim/es6-shim.js\">` in your `index.html`\r\n\r\nThis step is only required if you are using old versions of node/browser.\r\n\r\n#### Using in browser\r\n\r\nIf you are using class-validator with system.js in browser then use following configuration:\r\n\r\n```javascript\r\nSystem.config({\r\n    map: {\r\n        'class-validator': 'vendor/class-validator',\r\n        'validator': 'vendor/validator'\r\n    },\r\n    packages: {\r\n        'class-validator': { 'defaultExtension': 'js', 'main': 'index.js' },\r\n        'validator': { 'defaultExtension': 'js', 'main': 'validator.js' },\r\n    }\r\n};\r\n```\r\n\r\n## Usage\r\n\r\nCreate your class and put some validation decorators on the properties you want to validate:\r\n\r\n```javascript\r\nimport {validate, Contains, IsInt, Length, IsEmail, IsFQDN, IsDate, Min, Max} from \"class-validator\";\r\n\r\nexport class Post {\r\n\r\n    @Length(10, 20)\r\n    title: string;\r\n\r\n    @Contains(\"hello\")\r\n    text: string;\r\n\r\n    @IsInt()\r\n    @Min(0)\r\n    @Max(10)\r\n    rating: number;\r\n\r\n    @IsEmail()\r\n    email: string;\r\n\r\n    @IsFQDN()\r\n    site: string;\r\n\r\n    @IsDate()\r\n    createDate: Date;\r\n\r\n}\r\n\r\nlet post = new Post();\r\npost.title = \"Hello\"; // should not pass\r\npost.text = \"this is a great post about hell world\"; // should not pass\r\npost.rating = 11; // should not pass\r\npost.email = \"google.com\"; // should not pass\r\npost.site = \"googlecom\"; // should not pass\r\n\r\nvalidate(post).then(errors => { // errors is an array of validation errors\r\n    if (errors.length > 0) {\r\n        console.log(\"validation failed. errors: \", errors);\r\n    } else {\r\n        console.log(\"validation succeed\");\r\n    }\r\n});\r\n```\r\n\r\n## Validation errors\r\n\r\n`validate` method returns you an array of `ValidationError` objects. Each `ValidationError` is:\r\n\r\n```javascript\r\n{\r\n    target: Object; // Object that was validated.\r\n    property: string; // Object's property that haven't pass validation.\r\n    value: any; // Value that haven't pass a validation.\r\n    constraints?: { // Constraints that failed validation with error messages.\r\n        [type: string]: string;\r\n    };\r\n    children?: ValidationError[]; // Contains all nested validation errors of the property\r\n}\r\n```\r\n\r\nIn our case, when we validated a Post object, we have such array of ValidationErrors:\r\n\r\n```javascript\r\n[{\r\n    target: /* post object */,\r\n    property: \"title\",\r\n    value: \"Hello\",\r\n    constraints: {\r\n        length: \"$property must be shorter than 10 characters\"\r\n    }\r\n}, {\r\n    target: /* post object */,\r\n    property: \"text\",\r\n    value: \"this is a great post about hell world\",\r\n    constraints: {\r\n        contains: \"text must contain a hello string\"\r\n    }\r\n},\r\n// and other errors\r\n]\r\n```\r\n\r\nIf you don't want a `target` to be exposed in validation errors, there is a special option when you use validator:\r\n\r\n```javascript\r\nvalidator.validate(post, { validationError: { target: false } });\r\n```\r\n\r\nThis is especially useful when you send errors back over http, and you most probably don't want to expose\r\nthe whole target object.\r\n\r\n## Validation messages\r\n\r\nYou can specify validation message in the decorator options and that message will be returned in `ValidationError`\r\nreturned by `validate` method in the case that validation for this field fails.\r\n\r\n```javascript\r\nimport {MinLength, MaxLength} from \"class-validator\";\r\n\r\nexport class Post {\r\n\r\n    @MinLength(10, {\r\n        message: \"Title is too short\"\r\n    })\r\n    @MaxLength(50, {\r\n        message: \"Title is too long\"\r\n    })\r\n    title: string;\r\n}\r\n```\r\n\r\nThere are few special tokens you can use in your messages:\r\n* `$value` - the value that is being validated\r\n* `$property` - name of the object's property being validated\r\n* `$target` - name of the object's class being validated\r\n* `$constraint1`, `$constraint2`, ... `$constraintN` - constraints defined by specific validation type\r\n\r\nExample of usage:\r\n\r\n```javascript\r\nimport {MinLength, MaxLength} from \"class-validator\";\r\n\r\nexport class Post {\r\n\r\n    @MinLength(10, { // here, $constraint1 will be replaced with \"10\", and $value with actual supplied value\r\n        message: \"Title is too short. Minimal length is $constraint1 characters, but actual is $value\"\r\n    })\r\n    @MaxLength(50, { // here, $constraint1 will be replaced with \"50\", and $value with actual supplied value\r\n        message: \"Title is too long. Maximal length is $constraint1 characters, but actual is $value\"\r\n    })\r\n    title: string;\r\n}\r\n```\r\n\r\nAlso you can provide a function, that returns a message. This way allows to create more granular messages:\r\n\r\n```javascript\r\nimport {MinLength, MaxLength, ValidationArguments} from \"class-validator\";\r\n\r\nexport class Post {\r\n\r\n    @MinLength(10, {\r\n        message: (args: ValidationArguments) => {\r\n            if (args.value.length === 1) {\r\n                return \"Too short, minimum length is 1 character\";\r\n            } else {\r\n                return \"Too short, minimum length is \" + args.constraints[0] + \" characters\";\r\n            }\r\n        }\r\n    })\r\n    title: string;\r\n}\r\n```\r\n\r\nMessage function accepts `ValidationArguments` which contains following information:\r\n* `value` - the value that is being validated\r\n* `constraints` - array of constraints defined by specific validation type\r\n* `targetName` - name of the object's class being validated\r\n* `object` - object that is being validated\r\n* `property` - name of the object's property being validated\r\n\r\n## Validating arrays\r\n\r\nIf your field is an array and you want to perform validation of each item in the array you must specify a\r\nspecial `each: true` decorator option:\r\n\r\n```javascript\r\nimport {MinLength, MaxLength} from \"class-validator\";\r\n\r\nexport class Post {\r\n\r\n    @MaxLength(20, {\r\n        each: true\r\n    })\r\n    tags: string[];\r\n}\r\n```\r\n\r\nThis will validate each item in `post.tags` array.\r\n\r\n## Validating nested objects\r\n\r\nIf your object contains nested objects and you want the validator to perform their validation too, then you need to\r\nuse the `@ValidateNested()` decorator:\r\n\r\n```javascript\r\nimport {ValidateNested} from \"class-validator\";\r\n\r\nexport class Post {\r\n\r\n    @ValidateNested()\r\n    user: User;\r\n\r\n}\r\n```\r\n\r\n## Inheriting Validation decorators\r\n\r\nWhen you define a subclass which extends from another one, the subclass will automatically inherit the parent's decorators.\r\n```javascript\r\nimport {validate} from \"class-validator\";\r\n\r\nclass BaseContent {\r\n\r\n    @IsEmail()\r\n    email: string;\r\n}\r\n\r\nclass Post extends BaseContent {\r\n\r\n    @MinLength(10)\r\n    @MaxLength(20)\r\n    title: string;\r\n\r\n    @Contains(\"hello\")\r\n    text: string;\r\n}\r\n\r\nlet post = new Post();\r\npost.email = \"invalid email\";  // inherited property\r\npost.title = \"not valid\";\r\npost.text = \"helo\";\r\n\r\nvalidate(post).then(errors => {\r\n    // ...\r\n});  // it will return errors for email, title and text properties\r\n\r\n```\r\n\r\n## Conditional validation\r\n\r\nThe conditional validation decorator (`@ValidateIf`) can be used to ignore the validators on a property when the provided condition function returns false. The condition function takes the object being validated and must return a `boolean`.\r\n\r\n```javascript\r\nimport {ValidateIf, IsNotEmpty} from \"class-validator\";\r\n\r\nexport class Post {\r\n    otherProperty:string;\r\n    \r\n    @ValidateIf(o => o.otherProperty === \"value\")\r\n    @IsNotEmpty()\r\n    example:string;\r\n}\r\n```\r\n\r\nIn the example above, the validation rules applied to `example` won't be run unless the object's `otherProperty` is `\"value\"`.\r\n\r\nNote that when the condition is false all validation decorators are ignored, including `isDefined`.\r\n\r\n## Skipping missing properties\r\n\r\nSometimes you may want to skip validation of the properties that does not exist in the validating object. This is\r\nusually desirable when you want to update some parts of the object, and want to validate only updated parts,\r\nbut skip everything else, e.g. skip missing properties.\r\nIn such situations you will need to pass a special flag to `validate` method:\r\n\r\n```javascript\r\nimport {validate} from \"class-validator\";\r\n// ...\r\nvalidate(post, { skipMissingProperties: true });\r\n```\r\n\r\nWhen skipping missing properties, sometimes you want not to skip all missing properties, some of them maybe required\r\nfor you, even if skipMissingProperties is set to true. For such cases you should use `@IsDefined()` decorator.\r\n`@IsDefined()` is the only decorator that ignores `skipMissingProperties` option.\r\n\r\n## Validation groups\r\n\r\nIn different situations you may want to use different validation schemas of the same object.\r\n In such cases you can use validation groups.\r\n\r\n```javascript\r\nimport {validate, Min, Length} from \"class-validator\";\r\n\r\nexport class User {\r\n\r\n    @Min(12, {\r\n        groups: [\"registration\"]\r\n    })\r\n    age: number;\r\n\r\n    @Length(2, 20, {\r\n        groups: [\"registration\", \"admin\"]\r\n    })\r\n    name: string;\r\n}\r\n\r\nlet user = new User();\r\nuser.age = 10;\r\nuser.name = \"Alex\";\r\n\r\nvalidate(user, {\r\n    groups: [\"registration\"]\r\n}); // this will not pass validation\r\n\r\nvalidate(user, {\r\n    groups: [\"admin\"]\r\n}); // this will pass validation\r\n\r\nvalidate(user, {\r\n    groups: [\"registration\", \"admin\"]\r\n}); // this will not pass validation\r\n\r\nvalidate(user, {\r\n    groups: []\r\n}); // this will pass validation\r\n```\r\n\r\nThere is also a special flag `always: true` in validation options that you can use. This flag says that this validation\r\nmust be applied always no matter which group is used.\r\n\r\n## Custom validation classes\r\n\r\nIf you have custom validation logic you can create a *Constraint class*:\r\n\r\n1. First create a file, lets say `CustomTextLength.ts`, and define a new class:\r\n\r\n    ```javascript\r\n    import {ValidatorConstraint, ValidatorConstraintInterface, ValidationArguments} from \"class-validator\";\r\n\r\n    @ValidatorConstraint({ name: \"customText\", async: false })\r\n    export class CustomTextLength implements ValidatorConstraintInterface {\r\n\r\n        validate(text: string, args: ValidationArguments) {\r\n            return text.length > 1 && text.length < 10; // for async validations you must return a Promise<boolean> here\r\n        }\r\n\r\n        defaultMessage(args: ValidationArguments) { // here you can provide default error message if validation failed\r\n            return \"Text ($value) is too short or too long!\";\r\n        }\r\n\r\n    }\r\n    ```\r\n\r\n    We marked our class with `@ValidatorConstraint` decorator.\r\n    You can also supply a validation constraint name - this name will be used as \"error type\" in ValidationError.\r\n    If you will not supply a constraint name - it will be auto-generated.\r\n\r\n    Our class must implement `ValidatorConstraintInterface` interface and its `validate` method,\r\n    which defines validation logic. If validation succeeds, method returns true, otherwise false.\r\n    Custom validator can be asynchronous, if you want to perform validation after some asynchronous\r\n    operations, simply return a promise with boolean inside in `validate` method.\r\n\r\n    Also we defined optional method `defaultMessage` which defines a default error message,\r\n    in the case that the decorator's implementation doesn't set an error message.\r\n\r\n\r\n2. Then you can use your new validation constraint in your class:\r\n\r\n    ```javascript\r\n    import {Validate} from \"class-validator\";\r\n    import {CustomTextLength} from \"./CustomTextLength\";\r\n\r\n    export class Post {\r\n\r\n        @Validate(CustomTextLength, {\r\n            message: \"Title is too short or long!\"\r\n        })\r\n        title: string;\r\n\r\n    }\r\n    ```\r\n\r\n    Here we set our newly created `CustomTextLength` validation constraint for `Post.title`.\r\n\r\n3. And use validator as usual:\r\n\r\n    ```javascript\r\n    import {validate} from \"class-validator\";\r\n\r\n    validate(post).then(errors => {\r\n        // ...\r\n    });\r\n    ```\r\n\r\nYou can also pass constraints to your validator, like this:\r\n\r\n```javascript\r\nimport {Validate} from \"class-validator\";\r\nimport {CustomTextLength} from \"./CustomTextLength\";\r\n\r\nexport class Post {\r\n\r\n    @Validate(CustomTextLength, [3, 20], {\r\n        message: \"Wrong post title\"\r\n    })\r\n    title: string;\r\n\r\n}\r\n```\r\n\r\nAnd use them from `validationArguments` object:\r\n\r\n```javascript\r\nimport {ValidationArguments, ValidatorConstraint, ValidatorConstraintInterface} from \"class-validator\";\r\n\r\n@ValidatorConstraint()\r\nexport class CustomTextLength implements ValidatorConstraintInterface {\r\n\r\n    validate(text: string, validationArguments: ValidationArguments) {\r\n        return text.length > validationArguments.constraints[0] && text.length < validationArguments.constraints[1];\r\n    }\r\n\r\n}\r\n```\r\n\r\n## Custom validation decorators\r\n\r\nYou can also create a custom decorators. Its the most elegant way of using a custom validations.\r\nLets create a decorator called `@IsLongerThan`:\r\n\r\n1. Create a decorator itself:\r\n\r\n    ```javascript\r\n    import {registerDecorator, ValidationOptions, ValidationArguments} from \"class-validator\";\r\n\r\n    export function IsLongerThan(property: string, validationOptions?: ValidationOptions) {\r\n       return function (object: Object, propertyName: string) {\r\n            registerDecorator({\r\n                name: \"isLongerThan\",\r\n                target: object.constructor,\r\n                propertyName: propertyName,\r\n                options: validationOptions,\r\n                validator: {\r\n                    validate(value: any, args: ValidationArguments) {\r\n                        const [relatedPropertyName] = args.constraints;\r\n                        const relatedValue = (args.object as any)[relatedPropertyName];\r\n                        return  typeof value === \"string\" &&\r\n                               typeof relatedValue === \"string\" &&\r\n                               value.length > relatedValue.length; // you can return a Promise<boolean> here as well, if you want to make async validation\r\n                    }\r\n                }\r\n            });\r\n       };\r\n    }\r\n    ```\r\n\r\n2. Put it to use:\r\n\r\n    ```javascript\r\n    import {IsLongerThan} from \"./IsLongerThan\";\r\n\r\n    export class Post {\r\n\r\n        title: string;\r\n\r\n        @IsLongerThan(\"title\", {\r\n           /* you can also use additional validation options, like \"each\", \"groups\" in your custom validation decorators */\r\n           message: \"Text must be longer than the title\"\r\n        })\r\n        text: string;\r\n\r\n    }\r\n    ```\r\n\r\nIn your custom decorators you can also use `ValidationConstraint`.\r\nLets create another custom validation decorator called `IsUserAlreadyExist`:\r\n\r\n1. Create a ValidationConstraint and decorator:\r\n\r\n    ```javascript\r\n    import {registerDecorator, ValidationOptions, ValidatorConstraint, ValidatorConstraintInterface, ValidationArguments} from \"class-validator\";\r\n\r\n    @ValidatorConstraint({ async: true })\r\n    export class IsUserAlreadyExistConstraint implements ValidatorConstraintInterface {\r\n\r\n        validate(userName: any, args: ValidationArguments) {\r\n            return UserRepository.findOneByName(userName).then(user => {\r\n                if (user) return false;\r\n                return true;\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    export function IsUserAlreadyExist(validationOptions?: ValidationOptions) {\r\n       return function (object: Object, propertyName: string) {\r\n            registerDecorator({\r\n                target: object.constructor,\r\n                propertyName: propertyName,\r\n                options: validationOptions,\r\n                constraints: [],\r\n                validator: IsUserAlreadyExistConstraint\r\n            });\r\n       };\r\n    }\r\n    ```\r\n\r\n    note that we marked our constraint that it will by async by adding `{ async: true }` in validation options.\r\n\r\n2. And put it to use:\r\n\r\n    ```javascript\r\n    import {IsUserAlreadyExist} from \"./IsUserAlreadyExist\";\r\n\r\n    export class User {\r\n\r\n        @IsUserAlreadyExist({\r\n           message: \"User $value already exists. Choose another name.\"\r\n        })\r\n        name: string;\r\n\r\n    }\r\n    ```\r\n\r\n## Using service container\r\n\r\nValidator supports service container in the case if want to inject dependencies into your custom validator constraint\r\nclasses. Here is example how to integrate it with [typedi][2]:\r\n\r\n```javascript\r\nimport {Container} from \"typedi\";\r\nimport {useContainer, Validator} from \"class-validator\";\r\n\r\n// do this somewhere in the global application level:\r\nuseContainer(Container);\r\nlet validator = Container.get(Validator);\r\n\r\n// now everywhere you can inject Validator class which will go from the container\r\n// also you can inject classes using constructor injection into your custom ValidatorConstraint-s\r\n```\r\n\r\n## Synchronous validation\r\n\r\nIf you want to perform a simple non async validation you can use `validateSync` method instead of regular `validate`\r\n method. It has the same arguments as `validate` method. But note, this method **ignores** all async validations\r\n you have.\r\n\r\n## Manual validation\r\n\r\nThere are several method exist in the Validator that allows to perform non-decorator based validation:\r\n\r\n```javascript\r\nimport {Validator} from \"class-validator\";\r\n\r\n// Validation methods\r\nconst validator = new Validator();\r\n\r\n// common validation methods\r\nvalidator.isDefined(value); // Checks if value is defined (\"!==undefined\").\r\nvalidator.equals(value, comparison); // Checks if value matches (\"===\") the comparison.\r\nvalidator.notEquals(value, comparison); // Checks if value does not match (\"!==\") the comparison.\r\nvalidator.isEmpty(value); // Checks if given value is empty (=== '', === null, === undefined).\r\nvalidator.isNotEmpty(value); // Checks if given value is not empty (!== '', !== null, !== undefined).\r\nvalidator.isIn(value, possibleValues); // Checks if given value is in a array of allowed values.\r\nvalidator.isNotIn(value, possibleValues); // Checks if given value not in a array of allowed values.\r\n\r\n// type validation methods\r\nvalidator.isBoolean(value); // Checks if a given value is a real boolean.\r\nvalidator.isDate(value); // Checks if a given value is a real date.\r\nvalidator.isString(value); // Checks if a given value is a real string.\r\nvalidator.isArray(value); // Checks if a given value is an array.\r\nvalidator.isNumber(value); // Checks if a given value is a real number.\r\nvalidator.isInt(value); // Checks if value is an integer.\r\n\r\n// number validation methods\r\nvalidator.isDivisibleBy(value, num); // Checks if value is a number that's divisible by another.\r\nvalidator.isPositive(value); // Checks if the value is a positive number.\r\nvalidator.isNegative(value); // Checks if the value is a negative number.\r\nvalidator.max(num, max); // Checks if the first number is greater than second.\r\nvalidator.min(num, min); // Checks if the first number is less than second.\r\n\r\n// date validation methods\r\nvalidator.minDate(date, minDate); // Checks if the value is a date that's after the specified date.\r\nvalidator.maxDate(date, minDate); // Checks if the value is a date that's before the specified date.\r\n\r\n// string-type validation methods\r\nvalidator.isBooleanString(str); // Checks if a string is a boolean.\r\nvalidator.isDateString(str); // Checks if the string is a date.\r\nvalidator.isNumberString(str); // Checks if the string is numeric.\r\n\r\n// string validation methods\r\nvalidator.contains(str, seed); // Checks if the string contains the seed.\r\nvalidator.notContains(str, seed); // Checks if the string does not contain the seed.\r\nvalidator.isAlpha(str); // Checks if the string contains only letters (a-zA-Z).\r\nvalidator.isAlphanumeric(str); // Checks if the string contains only letters and numbers.\r\nvalidator.isAscii(str); // Checks if the string contains ASCII chars only.\r\nvalidator.isBase64(str); // Checks if a string is base64 encoded.\r\nvalidator.isByteLength(str, min, max); // Checks if the string's length (in bytes) falls in a range.\r\nvalidator.isCreditCard(str); // Checks if the string is a credit card.\r\nvalidator.isCurrency(str, options); // Checks if the string is a valid currency amount.\r\nvalidator.isEmail(str, options); // Checks if the string is an email.\r\nvalidator.isFQDN(str, options); // Checks if the string is a fully qualified domain name (e.g. domain.com).\r\nvalidator.isFullWidth(str); // Checks if the string contains any full-width chars.\r\nvalidator.isHalfWidth(str); // Checks if the string contains any half-width chars.\r\nvalidator.isVariableWidth(str); // Checks if the string contains variable-width chars.\r\nvalidator.isHexColor(str); // Checks if the string is a hexadecimal color.\r\nvalidator.isHexadecimal(str); // Checks if the string is a hexadecimal number.\r\nvalidator.isIP(str, version); // Checks if the string is an IP (version 4 or 6).\r\nvalidator.isISBN(str, version); // Checks if the string is an ISBN (version 10 or 13).\r\nvalidator.isISIN(str); // Checks if the string is an ISIN (stock/security identifier).\r\nvalidator.isISO8601(str); // Checks if the string is a valid ISO 8601 date.\r\nvalidator.isJSON(str); // Checks if the string is valid JSON (note: uses JSON.parse).\r\nvalidator.isLowercase(str); // Checks if the string is lowercase.\r\nvalidator.isMobilePhone(str, locale); // Checks if the string is a mobile phone number.\r\nvalidator.isMongoId(str); // Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\r\nvalidator.isMultibyte(str); // Checks if the string contains one or more multibyte chars.\r\nvalidator.isSurrogatePair(str); // Checks if the string contains any surrogate pairs chars.\r\nvalidator.isURL(str, options); // Checks if the string is an url.\r\nvalidator.isUUID(str, version); // Checks if the string is a UUID (version 3, 4 or 5).\r\nvalidator.isUppercase(str); // Checks if the string is uppercase.\r\nvalidator.length(str, min, max); // Checks if the string's length falls in a range.\r\nvalidator.minLength(str, min); // Checks if the string's length is not less than given number.\r\nvalidator.maxLength(str, max); // Checks if the string's length is not more than given number.\r\nvalidator.matches(str, pattern, modifiers); // Checks if string matches the pattern. Either matches('foo', /foo/i) or matches('foo', 'foo', 'i').\r\nvalidator.isMilitaryTime(str); // Checks if the string is a valid representation of military time in the format HH:MM.\r\n\r\n// array validation methods\r\nvalidator.arrayContains(array, values); // Checks if array contains all values from the given array of values.\r\nvalidator.arrayNotContains(array, values); // Checks if array does not contain any of the given values.\r\nvalidator.arrayNotEmpty(array); // Checks if given array is not empty.\r\nvalidator.arrayMinSize(array, min); // Checks if array's length is at least `min` number.\r\nvalidator.arrayMaxSize(array, max); // Checks if array's length is as most `max` number.\r\nvalidator.arrayUnique(array); // Checks if all array's values are unique. Comparison for objects is reference-based.\r\n```\r\n\r\n## Validation decorators\r\n\r\n| Decorator                                       | Description                                                                                                                      |\r\n|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------|\r\n| **Common validation decorators**                                                                                                                                                   |\r\n| `@IsDefined(value: any)`                        | Checks if value is defined (!== undefined, !== null). This is the only decorator that ignores skipMissingProperties option.      |\r\n| `@Equals(comparison: any)`                      | Checks if value equals (\"===\") comparison.                                                                                       |\r\n| `@NotEquals(comparison: any)`                   | Checks if value not equal (\"!==\") comparison.                                                                                    |\r\n| `@IsEmpty()`                                    | Checks if given value is empty (=== '', === null, === undefined).                                                                |\r\n| `@IsNotEmpty()`                                 | Checks if given value is not empty (!== '', !== null, !== undefined).                                                            |\r\n| `@IsIn(values: any[])`                          | Checks if value is in a array of allowed values.                                                                                 |\r\n| `@IsNotIn(values: any[])`                       | Checks if value is not in a array of disallowed values.                                                                          |\r\n| **Type validation decorators**                                                                                                                                                     |\r\n| `@IsBoolean()`                                  | Checks if a value is a boolean.                                                                                                  |\r\n| `@IsDate()`                                     | Checks if the string is a date.                                                                                                  |\r\n| `@IsString()`                                   | Checks if the string is a string.                                                                                                |\r\n| `@IsNumber()`                                   | Checks if the string is a number.                                                                                                |\r\n| `@IsInt()`                                      | Checks if the value is an integer number.                                                                                        |\r\n| `@IsArray()`                                    | Checks if the string is an array                                                                                                 |\r\n| **Number validation decorators**                                                                                                                                                   |\r\n| `@IsDivisibleBy(num: number)`                   | Checks if the value is a number that's divisible by another.                                                                     |\r\n| `@IsPositive()`                                 | Checks if the value is a positive number.                                                                                        |\r\n| `@IsNegative()`                                 | Checks if the value is a negative number.                                                                                        |\r\n| `@Max(max: number)`                             | Checks if the given number is greater than given number.                                                                         |\r\n| `@Min(min: number)`                             | Checks if the given number is less than given number.                                                                            |\r\n| **Date validation decorators**                                                                                                                                                     |\r\n| `@MinDate(date: Date)`                          | Checks if the value is a date that's after the specified date.                                                                   |\r\n| `@MaxDate(date: Date)`                          | Checks if the value is a date that's before the specified date.                                                                  |                                                                                                                                                  |\r\n| **String-type validation decorators**                                                                                                                                              |\r\n| `@IsBooleanString()`                            | Checks if a string is a boolean (e.g. is \"true\" or \"false\").                                                                     |\r\n| `@IsDateString()`                               | Checks if a string is a date.                                                                                                    |\r\n| `@IsNumberString()`                             | Checks if a string is a number.                                                                                                  |\r\n| **String validation decorators**                                                                                                                                                   |\r\n| `@Contains(seed: string)`                       | Checks if the string contains the seed.                                                                                          |\r\n| `@NotContains(seed: string)`                    | Checks if the string not contains the seed.                                                                                      |\r\n| `@IsAlpha()`                                    | Checks if the string contains only letters (a-zA-Z).                                                                             |\r\n| `@IsAlphanumeric()`                             | Checks if the string contains only letters and numbers.                                                                          |\r\n| `@IsAscii()`                                    | Checks if the string contains ASCII chars only.                                                                                  |\r\n| `@IsBase64()`                                   | Checks if a string is base64 encoded.                                                                                            |\r\n| `@IsByteLength(min: number, max?: number)`      | Checks if the string's length (in bytes) falls in a range.                                                                       |\r\n| `@IsCreditCard()`                               | Checks if the string is a credit card.                                                                                           |\r\n| `@IsCurrency(options?: IsCurrencyOptions)`      | Checks if the string is a valid currency amount.                                                                                 |\r\n| `@IsEmail(options?: IsEmailOptions)`            | Checks if the string is an email.                                                                                                |\r\n| `@IsFQDN(options?: IsFQDNOptions)`              | Checks if the string is a fully qualified domain name (e.g. domain.com).                                                         |\r\n| `@IsFullWidth()`                                | Checks if the string contains any full-width chars.                                                                              |\r\n| `@IsHalfWidth()`                                | Checks if the string contains any half-width chars.                                                                              |\r\n| `@IsVariableWidth()`                            | Checks if the string contains a mixture of full and half-width chars.                                                            |\r\n| `@IsHexColor()`                                 | Checks if the string is a hexadecimal color.                                                                                     |\r\n| `@IsHexadecimal()`                              | Checks if the string is a hexadecimal number.                                                                                    |\r\n| `@IsIP(version?: \"4\"|\"6\")`                      | Checks if the string is an IP (version 4 or 6).                                                                                  |\r\n| `@IsISBN(version?: \"10\"|\"13\")`                  | Checks if the string is an ISBN (version 10 or 13).                                                                              |\r\n| `@IsISIN()`                                     | Checks if the string is an ISIN (stock/security identifier).                                                                     |\r\n| `@IsISO8601()`                                  | Checks if the string is a valid ISO 8601 date.                                                                                   |\r\n| `@IsJSON()`                                     | Checks if the string is valid JSON.                                                                                              |\r\n| `@IsLowercase()`                                | Checks if the string is lowercase.                                                                                               |\r\n| `@IsMobilePhone(locale: string)`                | Checks if the string is a mobile phone number.                                                                                   |\r\n| `@IsMongoId()`                                  | Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.                                                |\r\n| `@IsMultibyte()`                                | Checks if the string contains one or more multibyte chars.                                                                       |\r\n| `@IsNumericString()`                            | Checks if the string is numeric.                                                                                                 |\r\n| `@IsSurrogatePair()`                            | Checks if the string contains any surrogate pairs chars.                                                                         |\r\n| `@IsUrl(options?: IsURLOptions)`                | Checks if the string is an url.                                                                                                  |\r\n| `@IsUUID(version?: \"3\"|\"4\"|\"5\")`                | Checks if the string is a UUID (version 3, 4 or 5).                                                                              |\r\n| `@IsUppercase()`                                | Checks if the string is uppercase.                                                                                               |\r\n| `@Length(min: number, max?: number)`            | Checks if the string's length falls in a range.                                                                                  |\r\n| `@MinLength(min: number)`                       | Checks if the string's length is not less than given number.                                                                     |\r\n| `@MaxLength(max: number)`                       | Checks if the string's length is not more than given number.                                                                     |\r\n| `@Matches(pattern: RegExp, modifiers?: string)` | Checks if string matches the pattern. Either matches('foo', /foo/i) or matches('foo', 'foo', 'i').\r\n| `@IsMilitaryTime()`                             | Checks if the string is a valid representation of military time in the format HH:MM.\r\n| **Array validation decorators**                                                                                                                                                    |\r\n| `@ArrayContains(values: any[])`                 | Checks if array contains all values from the given array of values.                                                              |\r\n| `@ArrayNotContains(values: any[])`              | Checks if array does not contain any of the given values.                                                                        |\r\n| `@ArrayNotEmpty()`                              | Checks if given array is not empty.                                                                                              |\r\n| `@ArrayMinSize(min: number)`                    | Checks if array's length is as minimal this number.                                                                              |\r\n| `@ArrayMaxSize(max: number)`                    | Checks if array's length is as maximal this number.                                                                              |\r\n| `@ArrayUnique()`                                | Checks if all array's values are unique. Comparison for objects is reference-based.                                              |\r\n\r\n## Defining validation schema without decorators\r\n\r\nYou can define your validation schemas without decorators:\r\n\r\n* you can define it in the separate object\r\n* you can define it in the `.json` file\r\n\r\nThis feature maybe useful in the cases if:\r\n\r\n* are using es5/es6 and don't have decorators available\r\n* you don't have a classes, and instead using interfaces\r\n* you don't want to use model at all\r\n* you want to have a validation schema separate of your model\r\n* you want beautiful json-schema based validation models\r\n* you simply hate decorators\r\n\r\nHere is an example of using it:\r\n\r\n1. Create a schema object:\r\n\r\n    ```javascript\r\n    import {ValidationSchema} from \"class-validator\";\r\n    export let UserValidationSchema: ValidationSchema = { // using interface here is not required, its just for type-safety\r\n        name: \"myUserSchema\", // this is required, and must be unique\r\n        properties: {\r\n            firstName: [{\r\n                type: \"minLength\", // validation type. All validation types are listed in ValidationTypes class.\r\n                constraints: [2]\r\n            }, {\r\n                type: \"maxLength\",\r\n                constraints: [20]\r\n            }],\r\n            lastName: [{\r\n                type: \"minLength\",\r\n                constraints: [2]\r\n            }, {\r\n                type: \"maxLength\",\r\n                constraints: [20]\r\n            }],\r\n            email: [{\r\n                type: \"isEmail\"\r\n            }]\r\n        }\r\n    };\r\n    ```\r\n\r\n    Same schema can be provided in `.json` file, depend on your wish.\r\n\r\n2. Register your schema:\r\n\r\n    ```javascript\r\n    import {registerSchema} from \"class-validator\";\r\n    import {UserValidationSchema} from \"./UserValidationSchema\";\r\n    registerSchema(schema); // if schema is in .json file, then you can simply do registerSchema(require(\"path-to-schema.json\"));\r\n    ```\r\n\r\n    Better to put this code in a global place, maybe when you bootstrap your application, for example in `app.ts`.\r\n\r\n3. Validate your object using validation schema:\r\n\r\n    ```javascript\r\n    import {validate} from \"class-validator\";\r\n    const user = { firstName: \"Johny\", secondName: \"Cage\", email: \"johny@cage.com\" };\r\n    validate(\"myUserSchema\", user).then(errors => {\r\n        if (errors.length > 0) {\r\n            console.log(\"Validation failed: \", errors);\r\n        } else {\r\n            console.log(\"Validation succeed.\");\r\n        }\r\n    });\r\n    ```\r\n\r\n    That's it. Here `\"myUserSchema\"` is the name of our validation schema.\r\n    `validate` method will perform validation based on this schema\r\n\r\n## Samples\r\n\r\nTake a look on samples in [./sample](https://github.com/pleerock/class-validator/tree/master/sample) for more examples of\r\nusages.\r\n\r\n\r\n## Release notes\r\n\r\nSee information about breaking changes and release notes [here](https://github.com/pleerock/class-validator/tree/master/doc/release-notes.md).\r\n\r\n[1]: https://github.com/chriso/validator.js\r\n[2]: https://github.com/pleerock/typedi\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/pleerock/class-validator.git"
  },
  "scripts": {
    "test": "gulp tests"
  },
  "tags": [
    "validator",
    "validation",
    "typescript",
    "typescript-validator"
  ],
  "version": "0.6.8"
}
