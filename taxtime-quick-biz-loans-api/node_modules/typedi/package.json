{
  "_args": [
    [
      {
        "raw": "typedi@^0.4.3",
        "scope": null,
        "escapedName": "typedi",
        "name": "typedi",
        "rawSpec": "^0.4.3",
        "spec": ">=0.4.3 <0.5.0",
        "type": "range"
      },
      "/home/gunungmerapi/wajid-projects/hyperledger-workspace/taxtime-quick-biz-loans-api"
    ]
  ],
  "_from": "typedi@>=0.4.3 <0.5.0",
  "_id": "typedi@0.4.3",
  "_inCache": true,
  "_location": "/typedi",
  "_nodeVersion": "6.6.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/typedi-0.4.3.tgz_1482692036001_0.9831678147893399"
  },
  "_npmUser": {
    "name": "pleerock",
    "email": "zarrhost@gmail.com"
  },
  "_npmVersion": "3.10.3",
  "_phantomChildren": {},
  "_requested": {
    "raw": "typedi@^0.4.3",
    "scope": null,
    "escapedName": "typedi",
    "name": "typedi",
    "rawSpec": "^0.4.3",
    "spec": ">=0.4.3 <0.5.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/typedi/-/typedi-0.4.3.tgz",
  "_shasum": "1e9ce98245a6ed74e0a4d19e08bfa6ebe2bab247",
  "_shrinkwrap": null,
  "_spec": "typedi@^0.4.3",
  "_where": "/home/gunungmerapi/wajid-projects/hyperledger-workspace/taxtime-quick-biz-loans-api",
  "author": {
    "name": "Umed Khudoiberdiev",
    "email": "pleerock.me@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/pleerock/typedi/issues"
  },
  "dependencies": {},
  "description": "Dependency injection for TypeScript",
  "devDependencies": {
    "chai": "^3.4.1",
    "del": "^2.2.1",
    "es6-shim": "^0.35.1",
    "gulp": "^3.9.1",
    "gulp-mocha": "^2.2.0",
    "gulp-replace": "^0.5.4",
    "gulp-shell": "^0.5.1",
    "gulp-sourcemaps": "^1.6.0",
    "gulp-tslint": "^6.0.1",
    "gulp-typescript": "^2.13.6",
    "gulpclass": "^0.1.1",
    "mocha": "^2.5.3",
    "reflect-metadata": "^0.1.3",
    "sinon": "^1.17.4",
    "sinon-chai": "^2.8.0",
    "tslint": "^3.13.0",
    "tslint-stylish": "^2.1.0-beta",
    "typescript": "^1.8.10",
    "typings": "^1.3.1"
  },
  "directories": {},
  "dist": {
    "shasum": "1e9ce98245a6ed74e0a4d19e08bfa6ebe2bab247",
    "tarball": "https://registry.npmjs.org/typedi/-/typedi-0.4.3.tgz"
  },
  "homepage": "https://github.com/pleerock/typedi#readme",
  "license": "MIT",
  "maintainers": [
    {
      "name": "pleerock",
      "email": "zarrhost@gmail.com"
    }
  ],
  "name": "typedi",
  "optionalDependencies": {},
  "private": false,
  "readme": "# TypeDI\r\n\r\nDependency injection tool for Typescript.\r\n\r\n## Installation\r\n\r\n\r\n1. Install module:\r\n\r\n    `npm install typedi --save`\r\n\r\n2. Use [typings](https://github.com/typings/typings) to install all required definition dependencies.\r\n\r\n    `typings install`\r\n\r\n3. ES6 features are used, so you may want to install [es6-shim](https://github.com/paulmillr/es6-shim) too. You also\r\nneed to install [reflect-metadata](https://www.npmjs.com/package/reflect-metadata) package.\r\n\r\n    `npm install es6-shim --save`\r\n    `npm install reflect-metadata --save`\r\n\r\n    if you are building nodejs app, you may want to `require(\"es6-shim\");` and `require(\"reflect-metadata\")` in your app.\r\n\r\n## Usage\r\n\r\nIf you simply want to use a container:\r\n\r\n```javascript\r\nimport {Container} from \"typedi\";\r\n\r\nclass SomeClass {\r\n\r\n    someMethod() {\r\n    }\r\n\r\n}\r\n\r\nlet someClass = Container.get(SomeClass);\r\nsomeClass.someMethod();\r\n```\r\n\r\nIf you want to inject other classes into your service you can do:\r\n\r\n```javascript\r\nimport {Container, Inject} from \"typedi\";\r\n\r\nclass BeanFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\nclass SugarFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\nclass WaterFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\nclass CoffeeMaker {\r\n\r\n    @Inject()\r\n    beanFactory: BeanFactory;\r\n    \r\n    @Inject()\r\n    sugarFactory: SugarFactory;\r\n    \r\n    @Inject()\r\n    waterFactory: WaterFactory;\r\n\r\n    make() {\r\n        this.beanFactory.create();\r\n        this.sugarFactory.create();\r\n        this.waterFactory.create();\r\n    }\r\n\r\n}\r\n\r\nlet coffeeMaker = Container.get(CoffeeMaker);\r\ncoffeeMaker.make();\r\n```\r\n\r\nIf you want to use constructor injection:\r\n\r\n```javascript\r\nimport {Container, Service} from \"typedi\";\r\n\r\nclass BeanFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\nclass SugarFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\nclass WaterFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service()\r\nclass CoffeeMaker {\r\n\r\n    private beanFactory: BeanFactory;\r\n    private sugarFactory: SugarFactory;\r\n    private waterFactory: WaterFactory;\r\n\r\n    constructor(beanFactory: BeanFactory, sugarFactory: SugarFactory, waterFactory: WaterFactory) {\r\n        this.beanFactory = beanFactory;\r\n        this.sugarFactory = sugarFactory;\r\n        this.waterFactory = waterFactory;\r\n    }\r\n\r\n    make() {\r\n        this.beanFactory.create();\r\n        this.sugarFactory.create();\r\n        this.waterFactory.create();\r\n    }\r\n\r\n}\r\n\r\nlet coffeeMaker = Container.get(CoffeeMaker);\r\ncoffeeMaker.make();\r\n```\r\n\r\n> note: Your classes may not to have `@Service` decorator to use it with Container, however its recommended to add\r\n`@Service` decorator to all classes you are using with container, especially if you class injects other\r\nservices\r\n\r\n### Extra feature: Injecting third-party dependencies *(experimental)*\r\n\r\nAlso you can inject a modules that you want to `require`:\r\n\r\n```javascript\r\nimport {Container, Service, Require} from \"typedi\";\r\n\r\n@Service()\r\nclass CoffeeMaker {\r\n\r\n    private gulp: any; // you can use type if you have definition for this package\r\n\r\n    constructor(@Require(\"gulp\") gulp: any) {\r\n        this.gulp = gulp; // the same if you do this.gulp = require(\"gulp\")\r\n    }\r\n\r\n    make() {\r\n        console.log(this.gulp); // here you get console.logged gulp package =)\r\n    }\r\n}\r\n\r\nlet coffeeMaker = Container.get(CoffeeMaker);\r\ncoffeeMaker.make();\r\n```\r\n\r\n### Named services\r\n\r\nYou can use a named services. In this case you can use interface-based services.\r\n\r\n```javascript\r\nimport {Container, Service, Inject} from \"typedi\";\r\n\r\ninterface Factory {\r\n    create(): void;\r\n}\r\n\r\n@Service(\"bean.factory\")\r\nclass BeanFactory implements Factory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service(\"sugar.factory\")\r\nclass SugarFactory implements Factory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service(\"water.factory\")\r\nclass WaterFactory implements Factory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service(\"coffee.maker\")\r\nclass CoffeeMaker {\r\n\r\n    beanFactory: Factory;\r\n    sugarFactory: Factory;\r\n\r\n    @Inject(\"water.factory\")\r\n    waterFactory: Factory;\r\n\r\n    constructor(@Inject(\"bean.factory\") beanFactory: BeanFactory,\r\n                @Inject(\"sugar.factory\") sugarFactory: SugarFactory) {\r\n        this.beanFactory = beanFactory;\r\n        this.sugarFactory = sugarFactory;\r\n    }\r\n\r\n    make() {\r\n        this.beanFactory.create();\r\n        this.sugarFactory.create();\r\n        this.waterFactory.create();\r\n    }\r\n\r\n}\r\n\r\nlet coffeeMaker = Container.get<CoffeeMaker>(\"coffee.maker\");\r\ncoffeeMaker.make();\r\n```\r\n\r\n### Providing values to the container\r\n\r\nIf you are writing unit tests for you class, you may want to provide fakes to your classes. You can use `set` or\r\n`provide` methods of the container:\r\n\r\n```javascript\r\nContainer.set(CoffeeMaker, new FakeCoffeeMaker());\r\n\r\n// or alternatively:\r\n\r\nContainer.provide([\r\n    { name: \"bean.factory\", type: BeanFactory, value: new FakeBeanFactory() },\r\n    { name: \"sugar.factory\", type: SugarFactory, value: new FakeSugarFactory() },\r\n    { name: \"water.factory\", type: WaterFactory, value: new FakeWaterFactory() }\r\n]);\r\n```\r\n\r\n### Problem with circular references\r\n\r\nThere is a known issue in language that it can't handle circular references. For example:\r\n\r\n```javascript\r\n// Car.ts\r\n@Service()\r\nexport class Car {\r\n    @Inject()\r\n    engine: Engine;\r\n}\r\n\r\n// Engine.ts\r\n@Service()\r\nexport class Engine {\r\n    @Inject()\r\n    car: Car;\r\n}\r\n```\r\n\r\nThis code will not work, because Engine has a reference to Car, and Car has a reference to Engine.\r\nOne of them will be undefined and it will cause an errors. To fix them you need to specify a type in a function like this:\r\n\r\n```javascript\r\n// Car.ts\r\n@Service()\r\nexport class Car {\r\n    @Inject(type => Engine)\r\n    engine: Engine;\r\n}\r\n\r\n// Engine.ts\r\n@Service()\r\nexport class Engine {\r\n    @Inject(type => Car)\r\n    car: Car;\r\n}\r\n```\r\n\r\nAnd that's all. Same for injects for constructor injection.\r\n\r\n### Inherited injections\r\n\r\nInherited injections are supported as well. In order to use them you must mark inherited class as a @Service.\r\nFor example:\r\n\r\n```javascript\r\n// Car.ts\r\n@Service()\r\nexport abstract class Car {\r\n\r\n    @Inject(type => Engine)\r\n    engine: Engine;\r\n\r\n}\r\n\r\n// Engine.ts\r\n@Service()\r\nexport class Bus extends Car {\r\n\r\n    // you can call this.engine in this class\r\n}\r\n```\r\n\r\n## Samples\r\n\r\nTake a look on samples in [./sample](https://github.com/pleerock/typedi/tree/master/sample) for more examples of\r\nusages.\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/pleerock/typedi.git"
  },
  "scripts": {
    "test": "gulp tests"
  },
  "tags": [
    "di",
    "typescript",
    "typescript-di",
    "dependency-injection",
    "typescript-require"
  ],
  "version": "0.4.3"
}
